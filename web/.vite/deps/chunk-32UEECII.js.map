{
  "version": 3,
  "sources": ["../../node_modules/permissionless/actions/bundler/chainId.ts", "../../node_modules/permissionless/utils/getAddressFromInitCodeOrPaymasterAndData.ts", "../../node_modules/permissionless/utils/getRequiredPrefund.ts", "../../node_modules/permissionless/utils/getUserOperationHash.ts", "../../node_modules/permissionless/utils/isSmartAccountDeployed.ts", "../../node_modules/permissionless/utils/walletClientToSmartAccountSigner.ts", "../../node_modules/permissionless/utils/providerToSmartAccountSigner.ts", "../../node_modules/permissionless/utils/getPackedUserOperation.ts", "../../node_modules/permissionless/utils/index.ts", "../../node_modules/permissionless/utils/signUserOperationHashWithECDSA.ts", "../../node_modules/permissionless/errors/utils.ts", "../../node_modules/permissionless/errors/estimateUserOperationGas.ts", "../../node_modules/permissionless/errors/account.ts", "../../node_modules/permissionless/errors/sendUserOperation.ts", "../../node_modules/permissionless/errors/paymaster.ts", "../../node_modules/permissionless/errors/bundler.ts", "../../node_modules/permissionless/errors/gas.ts", "../../node_modules/permissionless/utils/errors/getBundlerError.ts", "../../node_modules/permissionless/utils/errors/getSendUserOperationError.ts", "../../node_modules/permissionless/actions/bundler/sendUserOperation.ts", "../../node_modules/permissionless/utils/errors/getEstimateUserOperationGasError.ts", "../../node_modules/permissionless/actions/bundler/estimateUserOperationGas.ts", "../../node_modules/permissionless/actions/bundler/getUserOperationByHash.ts", "../../node_modules/permissionless/actions/bundler/getUserOperationReceipt.ts", "../../node_modules/permissionless/actions/bundler/supportedEntryPoints.ts", "../../node_modules/permissionless/utils/observe.ts", "../../node_modules/permissionless/actions/bundler/waitForUserOperationReceipt.ts", "../../node_modules/permissionless/clients/decorators/bundler.ts"],
  "sourcesContent": ["import type { Account, Chain, Client, Transport } from \"viem\"\nimport type { BundlerClient } from \"../../clients/createBundlerClient\"\nimport type { EntryPoint } from \"../../types\"\nimport type { BundlerRpcSchema } from \"../../types/bundler\"\n\n/**\n * Returns the supported chain id by the bundler service\n *\n * - Docs: https://docs.pimlico.io/permissionless/reference/bundler-actions/chainId\n *\n * @param client {@link BundlerClient} that you created using viem's createClient and extended it with bundlerActions.\n * @returns Supported chain id\n *\n *\n * @example\n * import { createClient } from \"viem\"\n * import { chainId } from \"permissionless/actions\"\n *\n * const bundlerClient = createClient({\n *      chain: goerli,\n *      transport: http(BUNDLER_URL)\n * })\n *\n * const bundlerChainId = chainId(bundlerClient)\n * // Return 5n for Goerli\n *\n */\nexport const chainId = async <\n    entryPoint extends EntryPoint,\n    TTransport extends Transport = Transport,\n    TChain extends Chain | undefined = Chain | undefined,\n    TAccount extends Account | undefined = Account | undefined\n>(\n    client: Client<TTransport, TChain, TAccount, BundlerRpcSchema<entryPoint>>\n) => {\n    return Number(\n        await client.request({\n            method: \"eth_chainId\",\n            params: []\n        })\n    )\n}\n", "import { type Address, type Hex, getAddress } from \"viem\"\n\nexport function getAddressFromInitCodeOrPaymasterAndData(\n    data: Hex\n): Address | undefined {\n    if (!data) {\n        return undefined\n    }\n    if (data.length >= 42) {\n        return getAddress(data.slice(0, 42))\n    }\n    return undefined\n}\n", "import type { EntryPoint, GetEntryPointVersion, UserOperation } from \"../types\"\nimport { ENTRYPOINT_ADDRESS_V06 } from \"./getEntryPointVersion\"\n\nexport type GetRequiredPrefundReturnType<entryPoint extends EntryPoint> = {\n    userOperation: UserOperation<GetEntryPointVersion<entryPoint>>\n    entryPoint: entryPoint\n}\n\n/**\n *\n * Returns the minimum required funds in the senders's smart account to execute the user operation.\n *\n * @param arags: {userOperation} as {@link UserOperation}\n * @returns requiredPrefund as {@link bigint}\n *\n * @example\n * import { getRequiredPrefund } from \"permissionless/utils\"\n *\n * const requiredPrefund = getRequiredPrefund({\n *     userOperation\n * })\n */\nexport const getRequiredPrefund = <entryPoint extends EntryPoint>({\n    userOperation,\n    entryPoint: entryPointAddress\n}: GetRequiredPrefundReturnType<entryPoint>): bigint => {\n    if (entryPointAddress === ENTRYPOINT_ADDRESS_V06) {\n        const userOperationVersion0_6 = userOperation as UserOperation<\"v0.6\">\n        const multiplier =\n            userOperationVersion0_6.paymasterAndData.length > 2\n                ? BigInt(3)\n                : BigInt(1)\n        const requiredGas =\n            userOperationVersion0_6.callGasLimit +\n            userOperationVersion0_6.verificationGasLimit * multiplier +\n            userOperationVersion0_6.preVerificationGas\n\n        return (\n            BigInt(requiredGas) * BigInt(userOperationVersion0_6.maxFeePerGas)\n        )\n    }\n\n    const userOperationV07 = userOperation as UserOperation<\"v0.7\">\n    const multiplier = userOperationV07.paymaster ? BigInt(3) : BigInt(1)\n\n    const verificationGasLimit =\n        userOperationV07.verificationGasLimit +\n        (userOperationV07.paymasterPostOpGasLimit || BigInt(0)) +\n        (userOperationV07.paymasterVerificationGasLimit || BigInt(0))\n\n    const requiredGas =\n        userOperationV07.callGasLimit +\n        verificationGasLimit * multiplier +\n        userOperationV07.preVerificationGas\n\n    return BigInt(requiredGas) * BigInt(userOperationV07.maxFeePerGas)\n}\n", "import type { Address, Hash, Hex } from \"viem\"\nimport { concat, encodeAbiParameters, keccak256, pad, toHex } from \"viem\"\nimport type { EntryPoint, GetEntryPointVersion } from \"../types\"\nimport type { UserOperation } from \"../types/userOperation\"\nimport { isUserOperationVersion06 } from \"./getEntryPointVersion\"\n\nfunction packUserOp<entryPoint extends EntryPoint>({\n    userOperation,\n    entryPoint: entryPointAddress\n}: {\n    userOperation: UserOperation<GetEntryPointVersion<entryPoint>>\n    entryPoint: entryPoint\n}): Hex {\n    if (isUserOperationVersion06(entryPointAddress, userOperation)) {\n        const hashedInitCode = keccak256(userOperation.initCode)\n        const hashedCallData = keccak256(userOperation.callData)\n        const hashedPaymasterAndData = keccak256(userOperation.paymasterAndData)\n\n        return encodeAbiParameters(\n            [\n                { type: \"address\" },\n                { type: \"uint256\" },\n                { type: \"bytes32\" },\n                { type: \"bytes32\" },\n                { type: \"uint256\" },\n                { type: \"uint256\" },\n                { type: \"uint256\" },\n                { type: \"uint256\" },\n                { type: \"uint256\" },\n                { type: \"bytes32\" }\n            ],\n            [\n                userOperation.sender as Address,\n                userOperation.nonce,\n                hashedInitCode,\n                hashedCallData,\n                userOperation.callGasLimit,\n                userOperation.verificationGasLimit,\n                userOperation.preVerificationGas,\n                userOperation.maxFeePerGas,\n                userOperation.maxPriorityFeePerGas,\n                hashedPaymasterAndData\n            ]\n        )\n    }\n\n    const hashedInitCode = keccak256(\n        userOperation.factory && userOperation.factoryData\n            ? concat([userOperation.factory, userOperation.factoryData])\n            : \"0x\"\n    )\n    const hashedCallData = keccak256(userOperation.callData)\n    const hashedPaymasterAndData = keccak256(\n        userOperation.paymaster\n            ? concat([\n                  userOperation.paymaster,\n                  pad(\n                      toHex(\n                          userOperation.paymasterVerificationGasLimit ||\n                              BigInt(0)\n                      ),\n                      {\n                          size: 16\n                      }\n                  ),\n                  pad(\n                      toHex(userOperation.paymasterPostOpGasLimit || BigInt(0)),\n                      {\n                          size: 16\n                      }\n                  ),\n                  userOperation.paymasterData || \"0x\"\n              ])\n            : \"0x\"\n    )\n\n    return encodeAbiParameters(\n        [\n            { type: \"address\" },\n            { type: \"uint256\" },\n            { type: \"bytes32\" },\n            { type: \"bytes32\" },\n            { type: \"bytes32\" },\n            { type: \"uint256\" },\n            { type: \"bytes32\" },\n            { type: \"bytes32\" }\n        ],\n        [\n            userOperation.sender as Address,\n            userOperation.nonce,\n            hashedInitCode,\n            hashedCallData,\n            concat([\n                pad(toHex(userOperation.verificationGasLimit), {\n                    size: 16\n                }),\n                pad(toHex(userOperation.callGasLimit), { size: 16 })\n            ]),\n            userOperation.preVerificationGas,\n            concat([\n                pad(toHex(userOperation.maxPriorityFeePerGas), {\n                    size: 16\n                }),\n                pad(toHex(userOperation.maxFeePerGas), { size: 16 })\n            ]),\n            hashedPaymasterAndData\n        ]\n    )\n}\n\nexport type GetUserOperationHashParams<entryPoint extends EntryPoint> = {\n    userOperation: UserOperation<GetEntryPointVersion<entryPoint>>\n    entryPoint: entryPoint\n    chainId: number\n}\n\n/**\n *\n * Returns user operation hash that is a unique identifier of the user operation.\n *\n * - Docs: https://docs.pimlico.io/permissionless/reference/utils/getUserOperationHash\n *\n * @param args: userOperation, entryPoint, chainId as {@link GetUserOperationHashParams}\n * @returns userOperationHash as {@link Hash}\n *\n * @example\n * import { getUserOperationHash } from \"permissionless/utils\"\n *\n * const userOperationHash = getUserOperationHash({\n *      userOperation,\n *      entryPoint,\n *      chainId\n * })\n *\n * // Returns \"0xe9fad2cd67f9ca1d0b7a6513b2a42066784c8df938518da2b51bb8cc9a89ea34\"\n *\n */\nexport const getUserOperationHash = <entryPoint extends EntryPoint>({\n    userOperation,\n    entryPoint: entryPointAddress,\n    chainId\n}: GetUserOperationHashParams<entryPoint>): Hash => {\n    const encoded = encodeAbiParameters(\n        [{ type: \"bytes32\" }, { type: \"address\" }, { type: \"uint256\" }],\n        [\n            keccak256(\n                packUserOp<entryPoint>({\n                    userOperation,\n                    entryPoint: entryPointAddress\n                })\n            ),\n            entryPointAddress,\n            BigInt(chainId)\n        ]\n    ) as `0x${string}`\n\n    return keccak256(encoded)\n}\n", "import type { Address, Client } from \"viem\"\nimport { getBytecode } from \"viem/actions\"\n\nexport const isSmartAccountDeployed = async (\n    client: Client,\n    address: Address\n): Promise<boolean> => {\n    const contractCode = await getBytecode(client, {\n        address: address\n    })\n\n    if ((contractCode?.length ?? 0) > 2) {\n        return true\n    }\n    return false\n}\n", "import type {\n    Account,\n    Address,\n    Chain,\n    Hex,\n    SignableMessage,\n    Transport,\n    TypedData,\n    TypedDataDefinition,\n    WalletClient\n} from \"viem\"\n\nimport { signTypedData } from \"viem/actions\"\nimport type { SmartAccountSigner } from \"../accounts/types\"\n\nexport function walletClientToSmartAccountSigner<\n    TChain extends Chain | undefined = Chain | undefined\n>(\n    walletClient: WalletClient<Transport, TChain, Account>\n): SmartAccountSigner<\"custom\", Address> {\n    return {\n        address: walletClient.account.address,\n        type: \"local\",\n        source: \"custom\",\n        publicKey: walletClient.account.address,\n        signMessage: async ({\n            message\n        }: { message: SignableMessage }): Promise<Hex> => {\n            return walletClient.signMessage({ message })\n        },\n        async signTypedData<\n            const TTypedData extends TypedData | Record<string, unknown>,\n            TPrimaryType extends\n                | keyof TTypedData\n                | \"EIP712Domain\" = keyof TTypedData\n        >(typedData: TypedDataDefinition<TTypedData, TPrimaryType>) {\n            return signTypedData<TTypedData, TPrimaryType, TChain, Account>(\n                walletClient,\n                {\n                    account: walletClient.account,\n                    ...typedData\n                }\n            )\n        }\n    }\n}\n", "import {\n    type EIP1193Provider,\n    type Hex,\n    createWalletClient,\n    custom\n} from \"viem\"\nimport { walletClientToSmartAccountSigner } from \"./walletClientToSmartAccountSigner\"\n\nexport const providerToSmartAccountSigner = async (\n    provider: EIP1193Provider,\n    params?: {\n        signerAddress: Hex\n    }\n) => {\n    let account: Hex\n    if (!params) {\n        try {\n            ;[account] = await provider.request({\n                method: \"eth_requestAccounts\"\n            })\n        } catch {\n            ;[account] = await provider.request({\n                method: \"eth_accounts\"\n            })\n        }\n    } else {\n        account = params.signerAddress\n    }\n    const walletClient = createWalletClient({\n        account: account as Hex,\n        transport: custom(provider)\n    })\n    return walletClientToSmartAccountSigner(walletClient)\n}\n", "import { type Hex, concat, getAddress, pad, slice, toHex } from \"viem\"\nimport type { UserOperation } from \"../types/userOperation\"\nimport type { Hex32, PackedUserOperation } from \"../types/userOperation\"\n\nexport function getInitCode(unpackedUserOperation: UserOperation<\"v0.7\">) {\n    return unpackedUserOperation.factory\n        ? concat([\n              unpackedUserOperation.factory,\n              unpackedUserOperation.factoryData || (\"0x\" as Hex)\n          ])\n        : \"0x\"\n}\n\nexport function unPackInitCode(initCode: Hex) {\n    if (initCode === \"0x\") {\n        return {\n            factory: null,\n            factoryData: null\n        }\n    }\n    return {\n        factory: getAddress(slice(initCode, 0, 20)),\n        factoryData: slice(initCode, 20)\n    }\n}\n\nexport function getAccountGasLimits(\n    unpackedUserOperation: UserOperation<\"v0.7\">\n) {\n    return concat([\n        pad(toHex(unpackedUserOperation.verificationGasLimit), {\n            size: 16\n        }),\n        pad(toHex(unpackedUserOperation.callGasLimit), { size: 16 })\n    ]) as Hex32\n}\n\nexport function unpackAccountGasLimits(accountGasLimits: Hex) {\n    return {\n        verificationGasLimit: BigInt(slice(accountGasLimits, 0, 16)),\n        callGasLimit: BigInt(slice(accountGasLimits, 16))\n    }\n}\n\nexport function getGasLimits(unpackedUserOperation: UserOperation<\"v0.7\">) {\n    return concat([\n        pad(toHex(unpackedUserOperation.maxPriorityFeePerGas), {\n            size: 16\n        }),\n        pad(toHex(unpackedUserOperation.maxFeePerGas), { size: 16 })\n    ]) as Hex32\n}\n\nexport function unpackGasLimits(gasLimits: Hex) {\n    return {\n        maxPriorityFeePerGas: BigInt(slice(gasLimits, 0, 16)),\n        maxFeePerGas: BigInt(slice(gasLimits, 16))\n    }\n}\n\nexport function getPaymasterAndData(\n    unpackedUserOperation: UserOperation<\"v0.7\">\n) {\n    return unpackedUserOperation.paymaster\n        ? concat([\n              unpackedUserOperation.paymaster,\n              pad(\n                  toHex(\n                      unpackedUserOperation.paymasterVerificationGasLimit ||\n                          BigInt(0)\n                  ),\n                  {\n                      size: 16\n                  }\n              ),\n              pad(\n                  toHex(\n                      unpackedUserOperation.paymasterPostOpGasLimit || BigInt(0)\n                  ),\n                  {\n                      size: 16\n                  }\n              ),\n              unpackedUserOperation.paymasterData || (\"0x\" as Hex)\n          ])\n        : \"0x\"\n}\n\nexport function unpackPaymasterAndData(paymasterAndData: Hex) {\n    if (paymasterAndData === \"0x\") {\n        return {\n            paymaster: null,\n            paymasterVerificationGasLimit: null,\n            paymasterPostOpGasLimit: null,\n            paymasterData: null\n        }\n    }\n    return {\n        paymaster: getAddress(slice(paymasterAndData, 0, 20)),\n        paymasterVerificationGasLimit: BigInt(slice(paymasterAndData, 20, 36)),\n        paymasterPostOpGasLimit: BigInt(slice(paymasterAndData, 36, 52)),\n        paymasterData: slice(paymasterAndData, 52)\n    }\n}\n\nexport const getPackedUserOperation = (\n    userOperation: UserOperation<\"v0.7\">\n): PackedUserOperation => {\n    return {\n        sender: userOperation.sender,\n        nonce: userOperation.nonce,\n        initCode: getInitCode(userOperation),\n        callData: userOperation.callData,\n        accountGasLimits: getAccountGasLimits(userOperation),\n        preVerificationGas: userOperation.preVerificationGas,\n        gasFees: getGasLimits(userOperation),\n        paymasterAndData: getPaymasterAndData(userOperation),\n        signature: userOperation.signature\n    }\n}\n", "import type { Account, Address } from \"viem\"\nimport { deepHexlify, transactionReceiptStatus } from \"./deepHexlify\"\nimport { getAddressFromInitCodeOrPaymasterAndData } from \"./getAddressFromInitCodeOrPaymasterAndData\"\nimport {\n    type GetRequiredPrefundReturnType,\n    getRequiredPrefund\n} from \"./getRequiredPrefund\"\nimport {\n    type GetUserOperationHashParams,\n    getUserOperationHash\n} from \"./getUserOperationHash\"\nimport { isSmartAccountDeployed } from \"./isSmartAccountDeployed\"\nimport { providerToSmartAccountSigner } from \"./providerToSmartAccountSigner\"\nimport {\n    AccountOrClientNotFoundError,\n    type SignUserOperationHashWithECDSAParams,\n    signUserOperationHashWithECDSA\n} from \"./signUserOperationHashWithECDSA\"\nimport { walletClientToSmartAccountSigner } from \"./walletClientToSmartAccountSigner\"\n\nexport function parseAccount(account: Address | Account): Account {\n    if (typeof account === \"string\")\n        return { address: account, type: \"json-rpc\" }\n    return account\n}\nimport {\n    ENTRYPOINT_ADDRESS_V06,\n    ENTRYPOINT_ADDRESS_V07,\n    getEntryPointVersion\n} from \"./getEntryPointVersion\"\n\nimport { getPackedUserOperation } from \"./getPackedUserOperation\"\n\nexport {\n    transactionReceiptStatus,\n    deepHexlify,\n    getUserOperationHash,\n    getRequiredPrefund,\n    walletClientToSmartAccountSigner,\n    type GetRequiredPrefundReturnType,\n    type GetUserOperationHashParams,\n    signUserOperationHashWithECDSA,\n    type SignUserOperationHashWithECDSAParams,\n    AccountOrClientNotFoundError,\n    isSmartAccountDeployed,\n    providerToSmartAccountSigner,\n    getAddressFromInitCodeOrPaymasterAndData,\n    getPackedUserOperation,\n    getEntryPointVersion,\n    ENTRYPOINT_ADDRESS_V06,\n    ENTRYPOINT_ADDRESS_V07\n}\n", "import {\n    type Account,\n    BaseError,\n    type Chain,\n    type Client,\n    type Hash,\n    type Hex,\n    type Transport\n} from \"viem\"\nimport type {\n    EntryPoint,\n    GetAccountParameterWithClient,\n    GetEntryPointVersion\n} from \"../types/\"\nimport type { UserOperation } from \"../types/userOperation\"\nimport { parseAccount } from \"./\"\nimport { getUserOperationHash } from \"./getUserOperationHash\"\n\nexport type SignUserOperationHashWithECDSAParams<\n    entryPoint extends EntryPoint,\n    TTransport extends Transport = Transport,\n    TChain extends Chain | undefined = Chain | undefined,\n    TAccount extends Account | undefined = Account | undefined\n> = GetAccountParameterWithClient<TTransport, TChain, TAccount> &\n    (\n        | {\n              hash: Hash\n              userOperation?: undefined\n              entryPoint?: undefined\n              chainId?: undefined\n          }\n        | {\n              hash?: undefined\n              userOperation: UserOperation<GetEntryPointVersion<entryPoint>>\n              entryPoint: entryPoint\n              chainId: number\n          }\n    )\n\nexport class AccountOrClientNotFoundError extends BaseError {\n    override name = \"AccountOrClientNotFoundError\"\n    constructor({ docsPath }: { docsPath?: string } = {}) {\n        super(\n            [\n                \"Could not find an Account to execute with this Action.\",\n                \"Please provide an Account with the `account` argument on the Action, or by supplying an `account` to the WalletClient.\"\n            ].join(\"\\n\"),\n            {\n                docsPath,\n                docsSlug: \"account\"\n            }\n        )\n    }\n}\n\n/**\n *\n * Returns signature for user operation. It signs over user operation hash.\n * If you have a custom way of signing user operation hash, you can use this function to sign it with ECDSA.\n *\n * - Docs: https://docs.pimlico.io/permissionless/reference/utils/signUserOperationHashWithECDSA\n *\n * @param signer: owner as {@link Client<Transport, TChain, TAccount>}\n * @param params: account & (userOperation, entryPoint, chainId)  | hash to sign\n * @returns signature as {@link Hash}\n *\n * @example\n * import { signUserOperationHashWithECDSA } from \"permissionless/utils\"\n *\n * const userOperationSignature = signUserOperationHashWithECDSA(owner, {\n *      userOperation,\n *      entryPoint,\n *      chainId\n * })\n *\n * // Returns \"0x7d9ae17d5e617e4bf3221dfcb69d64d824959e5ae2ef7078c6ddc3a4fe26c8301ab39277c61160dca68ca90071eb449d9fb2fbbc78b3614d9d7282c860270e291c\"\n *\n */\nexport const signUserOperationHashWithECDSA = async <\n    entryPoint extends EntryPoint,\n    TTransport extends Transport = Transport,\n    TChain extends Chain | undefined = Chain | undefined,\n    TAccount extends Account | undefined = Account | undefined\n>({\n    client,\n    account: account_ = client?.account,\n    hash,\n    userOperation,\n    chainId,\n    entryPoint: entryPointAddress\n}: SignUserOperationHashWithECDSAParams<\n    entryPoint,\n    TTransport,\n    TChain,\n    TAccount\n>): Promise<Hex> => {\n    if (!account_)\n        throw new AccountOrClientNotFoundError({\n            docsPath:\n                \"/permissionless/reference/utils/signUserOperationHashWithECDSA\"\n        })\n\n    let userOperationHash: Hash\n\n    if (hash) {\n        userOperationHash = hash\n    } else {\n        userOperationHash = getUserOperationHash<entryPoint>({\n            userOperation,\n            chainId,\n            entryPoint: entryPointAddress\n        })\n    }\n\n    const account = parseAccount(account_)\n\n    if (account.type === \"local\")\n        return account.signMessage({\n            message: {\n                raw: userOperationHash\n            }\n        })\n\n    if (!client)\n        throw new AccountOrClientNotFoundError({\n            docsPath:\n                \"/permissionless/reference/utils/signUserOperationHashWithECDSA\"\n        })\n\n    return client.request({\n        method: \"personal_sign\",\n        params: [userOperationHash, account.address]\n    })\n}\n", "export type ErrorType<name extends string = \"Error\"> = Error & { name: name }\n\nexport function prettyPrint(\n    args: Record<string, bigint | number | string | undefined | false | unknown>\n) {\n    const entries = Object.entries(args)\n        .map(([key, value]) => {\n            if (value === undefined || value === false) return null\n            return [key, value]\n        })\n        .filter(Boolean) as [string, string][]\n    const maxLength = entries.reduce(\n        (acc, [key]) => Math.max(acc, key.length),\n        0\n    )\n    return entries\n        .map(([key, value]) => `  ${`${key}:`.padEnd(maxLength + 1)}  ${value}`)\n        .join(\"\\n\")\n}\n", "import { BaseError } from \"viem\"\nimport type { EstimateUserOperationGasParameters } from \"../actions/bundler/estimateUserOperationGas\"\nimport type { EntryPoint } from \"../types/entrypoint\"\nimport { prettyPrint } from \"./utils\"\n\nexport type EstimateUserOperationGasErrorType<entryPoint extends EntryPoint> =\n    EstimateUserOperationGasError<entryPoint> & {\n        name: \"EstimateUserOperationGasError\"\n    }\nexport class EstimateUserOperationGasError<\n    entryPoint extends EntryPoint\n> extends BaseError {\n    override cause: BaseError\n\n    override name = \"EstimateUserOperationGasError\"\n\n    constructor(\n        cause: BaseError,\n        {\n            userOperation,\n            entryPoint,\n            docsPath\n        }: EstimateUserOperationGasParameters<entryPoint> & {\n            docsPath?: string\n        }\n    ) {\n        const prettyArgs = prettyPrint({\n            sender: userOperation.sender,\n            nonce: userOperation.nonce,\n            initCode: userOperation.initCode,\n            callData: userOperation.callData,\n            callGasLimit: userOperation.callGasLimit,\n            verificationGasLimit: userOperation.verificationGasLimit,\n            preVerificationGas: userOperation.preVerificationGas,\n            maxFeePerGas: userOperation.maxFeePerGas,\n            maxPriorityFeePerGas: userOperation.maxPriorityFeePerGas,\n            paymasterAndData: userOperation.paymasterAndData,\n            signature: userOperation.signature,\n            entryPoint\n        })\n\n        super(cause.shortMessage, {\n            cause,\n            docsPath,\n            metaMessages: [\n                ...(cause.metaMessages ? [...cause.metaMessages, \" \"] : []),\n                \"Estimate Gas Arguments:\",\n                prettyArgs\n            ].filter(Boolean) as string[]\n        })\n        this.cause = cause\n    }\n}\n", "import { type Address, BaseError } from \"viem\"\n\nexport type SenderAlreadyDeployedErrorType = SenderAlreadyDeployedError & {\n    name: \"SenderAlreadyDeployedError\"\n}\nexport class SenderAlreadyDeployedError extends BaseError {\n    static message = /aa10/\n    override name = \"SenderAlreadyDeployedError\" as const\n    constructor({\n        cause,\n        sender,\n        docsPath\n    }: { cause?: BaseError; sender?: Address; docsPath?: string } = {}) {\n        super(\n            [\n                `Smart account ${sender} is already deployed.`,\n                \"\",\n                \"Possible solutions:\",\n                `• Remove the initCode from the user operation and set it to \"0x\"`,\n                \"\",\n                docsPath ? `Docs: ${docsPath}` : \"\"\n            ].join(\"\\n\"),\n            {\n                cause\n            }\n        )\n    }\n}\n\nexport type InitCodeRevertedErrorType = InitCodeRevertedError & {\n    name: \"InitCodeRevertedError\"\n}\nexport class InitCodeRevertedError extends BaseError {\n    static message = /aa13/\n    override name = \"InitCodeRevertedError\" as const\n    constructor({\n        cause,\n        docsPath\n    }: { cause?: BaseError; docsPath?: string } = {}) {\n        super(\n            [\n                \"EntryPoint failed to create the smart account with the initCode provided.\",\n                \"\",\n                \"Possible reasons:\",\n                \"• The initCode ran out of gas\",\n                \"• The initCode reverted during the account deployment process\",\n                \"\",\n                \"Possible solutions:\",\n                \"• Verify that the factory address in the initCode is correct (the factory address is the first 20 bytes of the initCode).\",\n                \"• Verify that the initCode is correct.\",\n                \"• Check whether the verificationGasLimit is sufficient for the initCode to complete without running out of gas.\",\n                \"\",\n                docsPath ? `Docs: ${docsPath}` : \"\"\n            ].join(\"\\n\"),\n            {\n                cause\n            }\n        )\n    }\n}\n\nexport type SenderAddressMismatchErrorType = SenderAddressMismatchError & {\n    name: \"SenderAddressMismatchError\"\n}\nexport class SenderAddressMismatchError extends BaseError {\n    static message = /aa14/\n    override name = \"SenderAddressMismatchError\" as const\n    constructor({\n        cause,\n        sender,\n        docsPath\n    }: {\n        cause?: BaseError\n        sender: Address\n        docsPath?: string\n    }) {\n        super(\n            [\n                \"The initCode returned a different smart account address than expected.\",\n                `Expected: ${sender}`,\n                \"\",\n                \"Possible reasons:\",\n                \"• Account deployed with the initCode provided does not match match the sender address provided\",\n                \"\",\n                \"Possible solutions:\",\n                \"• Verify that the sender address was generated deterministically from the initCode. (consider leveraging functions like getSenderAddress)\",\n                \"• Verify that the factory address in the initCode is correct (the factory address is the first 20 bytes of the initCode)\",\n                \"• Verify that the initCode is correct.\",\n                \"\",\n                docsPath ? `Docs: ${docsPath}` : \"\"\n            ].join(\"\\n\"),\n            {\n                cause\n            }\n        )\n    }\n}\n\nexport type InitCodeDidNotDeploySenderErrorType =\n    InitCodeDidNotDeploySenderError & {\n        name: \"InitCodeDidNotDeploySenderError\"\n    }\nexport class InitCodeDidNotDeploySenderError extends BaseError {\n    static message = /aa15/\n    override name = \"InitCodeDidNotDeploySenderError\" as const\n    constructor({\n        cause,\n        sender,\n        docsPath\n    }: {\n        cause?: BaseError\n        sender: Address\n        docsPath?: string\n    }) {\n        super(\n            [\n                `The initCode did not deploy the sender at the address ${sender}.`,\n                \"\",\n                \"Possible reasons:\",\n                \"• The initCode factory is not creating an account.\",\n                \"• The initCode factory is creating an account, but is not implemented correctly as it is not deploying at the sender address\",\n                \"\",\n                \"Possible solutions:\",\n                \"• Verify that the factory address in the initCode is correct (the factory address is the first 20 bytes of the initCode).\",\n                \"• Verify that the initCode factory is implemented correctly. The factory must deploy the smart account at the sender address.\",\n                \"\",\n                docsPath ? `Docs: ${docsPath}` : \"\"\n            ].join(\"\\n\"),\n            {\n                cause\n            }\n        )\n    }\n}\n\nexport type SenderNotDeployedErrorType = SenderNotDeployedError & {\n    name: \"SenderNotDeployedError\"\n}\nexport class SenderNotDeployedError extends BaseError {\n    static message = /aa20/\n    override name = \"SenderNotDeployedError\" as const\n    constructor({\n        cause,\n        sender,\n        docsPath\n    }: {\n        cause?: BaseError\n        sender: Address\n        docsPath?: string\n    }) {\n        super(\n            [\n                `Smart account ${sender} is not deployed.`,\n                \"\",\n                \"Possible reasons:\",\n                \"• An initCode was not specified, but the sender address (i.e. the smart account) is not deployed.\",\n                \"\",\n                \"Possible solutions:\",\n                \"• If this is the first transaction by this account, make sure the initCode is included in the user operation.\",\n                \"• If the smart account is already supposed to be deployed, verify that you have selected the correct sender address for the user operation.\",\n                \"\",\n                docsPath ? `Docs: ${docsPath}` : \"\"\n            ].join(\"\\n\"),\n            {\n                cause\n            }\n        )\n    }\n}\n\nexport type SmartAccountInsufficientFundsErrorType =\n    SmartAccountInsufficientFundsError & {\n        name: \"SmartAccountInsufficientFundsError\"\n    }\nexport class SmartAccountInsufficientFundsError extends BaseError {\n    static message = /aa21/\n    override name = \"SmartAccountInsufficientFundsError\" as const\n    constructor({\n        cause,\n        sender,\n        docsPath\n    }: {\n        cause?: BaseError\n        sender: Address\n        docsPath?: string\n    }) {\n        super(\n            [\n                `You are not using a paymaster, and the ${sender} address did not have enough native tokens to cover the gas costs associated with the user operation.`,\n                \"\",\n                \"Possible solutions:\",\n                \"• If you are not using a paymaster, verify that the sender address has enough native tokens to cover the required prefund. Consider leveraging functions like getRequiredPrefund.\",\n                \"• If you are looking to use a paymaster to cover the gas fees, verify that the paymasterAndData field is set.\",\n                \"\",\n                docsPath ? `Docs: ${docsPath}` : \"\"\n            ].join(\"\\n\"),\n            {\n                cause\n            }\n        )\n    }\n}\n\nexport type SmartAccountSignatureValidityPeriodErrorType =\n    SmartAccountSignatureValidityPeriodError & {\n        name: \"SmartAccountSignatureValidityPeriodError\"\n    }\nexport class SmartAccountSignatureValidityPeriodError extends BaseError {\n    static message = /aa22/\n    override name = \"SmartAccountSignatureValidityPeriodError\" as const\n    constructor({\n        cause,\n        docsPath\n    }: {\n        cause?: BaseError\n        docsPath?: string\n    }) {\n        super(\n            [\n                \"The signature used in the user operation is not valid, because it is outside of the time range it specified.\",\n                \"\",\n                \"Possible reasons:\",\n                \"• This error occurs when the block.timestamp falls after the validUntil timestamp, or before the validAfter timestamp.\",\n                \"\",\n                \"Possible solutions:\",\n                \"• If you are looking to use time-based signatures, verify that the validAfter and validUntil fields are set correctly and that the user operation is sent within the specified range.\",\n                \"• If you are not looking to use time-based signatures, verify that the validAfter and validUntil fields are set to 0.\",\n                \"\",\n                docsPath ? `Docs: ${docsPath}` : \"\"\n            ].join(\"\\n\"),\n            {\n                cause\n            }\n        )\n    }\n}\n\nexport type SmartAccountValidationRevertedErrorType =\n    SmartAccountValidationRevertedError & {\n        name: \"SmartAccountValidationRevertedError\"\n    }\nexport class SmartAccountValidationRevertedError extends BaseError {\n    static message = /aa23/\n    override name = \"SmartAccountValidationRevertedError\" as const\n    constructor({\n        cause,\n        sender,\n        docsPath\n    }: {\n        cause?: BaseError\n        sender: Address\n        docsPath?: string\n    }) {\n        super(\n            [\n                `The smart account ${sender} reverted or ran out of gas during the validation of the user operation.`,\n                \"\",\n                \"Possible solutions:\",\n                \"• Verify that the verificationGasLimit is high enough to cover the validateUserOp function's gas costs.\",\n                \"• Make sure validateUserOp returns uint(1) for invalid signatures, and MUST NOT REVERT when the signature is invalid\",\n                \"• If you are not using a paymaster, verify that the sender address has enough native tokens to cover the required pre fund. Consider leveraging functions like getRequiredPrefund.\",\n                \"• Verify that the validateUserOp function is implemented with the correct logic, and that the user operation is supposed to be valid.\",\n                \"\",\n                docsPath ? `Docs: ${docsPath}` : \"\"\n            ].join(\"\\n\"),\n            {\n                cause\n            }\n        )\n    }\n}\n\nexport type InvalidSmartAccountSignatureErrorType =\n    InvalidSmartAccountSignatureError & {\n        name: \"InvalidSmartAccountSignatureError\"\n    }\nexport class InvalidSmartAccountSignatureError extends BaseError {\n    static message = /aa24/\n    override name = \"InvalidSmartAccountSignatureError\" as const\n    constructor({\n        cause,\n        sender,\n        docsPath\n    }: {\n        cause?: BaseError\n        sender: Address\n        docsPath?: string\n    }) {\n        super(\n            [\n                `The smart account ${sender} signature is invalid.`,\n                \"\",\n                \"Possible solutions:\",\n                \"• Verify that the user operation was correctly signed, and that the signature was correctly encoded in the signature field of the user operation.\",\n                \"• Most smart account implementations sign over the userOpHash. Make sure that the userOpHash is correctly computed. Consider leveraging functions like getUserOperationHash.\",\n                \"• Make sure you have selected the correct chainId and entryPointAddress when computing the userOpHash.\",\n                \"• Make sure the smart account signature verification function is correctly implemented.\",\n                \"\",\n                docsPath ? `Docs: ${docsPath}` : \"\"\n            ].join(\"\\n\"),\n            {\n                cause\n            }\n        )\n    }\n}\n\nexport type InvalidSmartAccountNonceErrorType =\n    InvalidSmartAccountNonceError & {\n        name: \"InvalidSmartAccountNonceError\"\n    }\nexport class InvalidSmartAccountNonceError extends BaseError {\n    static message = /aa25/\n    override name = \"InvalidSmartAccountNonceError\" as const\n    constructor({\n        cause,\n        sender,\n        nonce,\n        docsPath\n    }: {\n        cause?: BaseError\n        sender: Address\n        docsPath?: string\n        nonce: bigint\n    }) {\n        const nonceKey = nonce >> BigInt(64) // first 192 bits of nonce\n        const nonceSequence = nonce & 0xffffffffffffffffn // last 64 bits of nonce\n\n        super(\n            [\n                `The smart account ${sender} nonce is invalid.`,\n                `Nonce sent: ${nonce} (key: ${nonceKey}, sequence: ${nonceSequence})`,\n                \"\",\n                \"Possible solutions:\",\n                \"• Verify that you are using the correct nonce for the user operation. The nonce should be the current nonce of the smart account for the selected key. Consider leveraging functions like getAccountNonce.\",\n                \"• Verify that the nonce is formatted correctly.\",\n                \"\",\n                docsPath ? `Docs: ${docsPath}` : \"\"\n            ].join(\"\\n\"),\n            {\n                cause\n            }\n        )\n    }\n}\n", "import { BaseError } from \"viem\"\nimport { type SendUserOperationParameters } from \"../actions/bundler/sendUserOperation\"\nimport type { EntryPoint } from \"../types/entrypoint\"\nimport { prettyPrint } from \"./utils\"\n\nexport type SendUserOperationErrorType<entryPoint extends EntryPoint> =\n    SendUserOperationError<entryPoint> & {\n        name: \"SendUserOperationError\"\n    }\nexport class SendUserOperationError<\n    entryPoint extends EntryPoint\n> extends BaseError {\n    override cause: BaseError\n\n    override name = \"SendUserOperationError\"\n\n    constructor(\n        cause: BaseError,\n        {\n            userOperation,\n            entryPoint,\n            docsPath\n        }: SendUserOperationParameters<entryPoint> & {\n            docsPath?: string\n        }\n    ) {\n        const prettyArgs = prettyPrint({\n            ...userOperation,\n            entryPoint\n        })\n\n        super(cause.shortMessage, {\n            cause,\n            docsPath,\n            metaMessages: [\n                ...(cause.metaMessages ? [...cause.metaMessages, \" \"] : []),\n                \"sendUserOperation Arguments:\",\n                prettyArgs\n            ].filter(Boolean) as string[]\n        })\n        this.cause = cause\n    }\n}\n", "import { BaseError, type Hex } from \"viem\"\nimport { getAddressFromInitCodeOrPaymasterAndData } from \"../utils/\"\n\nexport type PaymasterNotDeployedErrorType = PaymasterNotDeployedError & {\n    name: \"PaymasterNotDeployedError\"\n}\nexport class PaymasterNotDeployedError extends BaseError {\n    static message = /aa30/\n    override name = \"PaymasterNotDeployedError\"\n    constructor({\n        cause,\n        paymasterAndData,\n        docsPath\n    }: {\n        cause?: BaseError\n        paymasterAndData?: Hex\n        docsPath?: string\n    } = {}) {\n        const paymaster = paymasterAndData\n            ? getAddressFromInitCodeOrPaymasterAndData(paymasterAndData)\n            : \"0x\"\n\n        super(\n            [\n                `Paymaster ${paymaster} is not deployed.`,\n                \"\",\n                \"Possible solutions:\",\n                \"• Verify that the paymasterAndData field is correct, and that the first 20 bytes are the address of the paymaster contract you intend to use.\",\n                \"• Verify that the paymaster contract is deployed on the network you are using.\",\n                \"\",\n                docsPath ? `Docs: ${docsPath}` : \"\"\n            ].join(\"\\n\"),\n            {\n                cause\n            }\n        )\n    }\n}\n\nexport type PaymasterDepositTooLowErrorType = PaymasterDepositTooLowError & {\n    name: \"PaymasterDepositTooLowError\"\n}\nexport class PaymasterDepositTooLowError extends BaseError {\n    static message = /aa31/\n    override name = \"PaymasterDepositTooLowError\"\n    constructor({\n        cause,\n        paymasterAndData,\n        docsPath\n    }: {\n        cause?: BaseError\n        paymasterAndData?: Hex\n        docsPath?: string\n    } = {}) {\n        const paymaster = paymasterAndData\n            ? getAddressFromInitCodeOrPaymasterAndData(paymasterAndData)\n            : \"0x\"\n\n        super(\n            [\n                `Paymaster ${paymaster} contract does not have enough funds deposited into the EntryPoint contract to cover the required funds for the user operation.`,\n                \"\",\n                \"Possible solutions:\",\n                \"• If you are using your own paymaster contract, deposit more funds into the EntryPoint contract through the deposit() function of the paymaster contract.\",\n                \"• Verify that the paymasterAndData field is correct, and that the first 20 bytes are the address of the paymaster contract you intend to useVerify that the paymasterAndData field is correct, and that the first 20 bytes are the address of the paymaster contract you intend to use.\",\n                \"• If you are using a paymaster service, reach out to them.\",\n                \"\",\n                docsPath ? `Docs: ${docsPath}` : \"\"\n            ].join(\"\\n\"),\n            {\n                cause\n            }\n        )\n    }\n}\n\nexport type PaymasterValidityPeriodErrorType = PaymasterValidityPeriodError & {\n    name: \"PaymasterValidityPeriodError\"\n}\nexport class PaymasterValidityPeriodError extends BaseError {\n    static message = /aa32/\n    override name = \"PaymasterValidityPeriodError\"\n    constructor({\n        cause,\n        paymasterAndData,\n        docsPath\n    }: {\n        cause?: BaseError\n        paymasterAndData?: Hex\n        docsPath?: string\n    }) {\n        const paymaster = paymasterAndData\n            ? getAddressFromInitCodeOrPaymasterAndData(paymasterAndData)\n            : \"0x\"\n\n        super(\n            [\n                `Paymaster ${paymaster}'s data used in the paymasterAndData field of the user operation is not valid, because it is outside of the time range it specified.`,\n                \"\",\n                \"Possible reasons:\",\n                \"• This error occurs when the block.timestamp falls after the validUntil timestamp, or before the validAfter timestamp.\",\n                \"\",\n                \"Possible solutions:\",\n                \"• If you are using your own paymaster contract and using time-based signatures, verify that the validAfter and validUntil fields are set correctly and that the user operation is sent within the specified range.\",\n                \"• If you are using your own paymaster contract and not looking to use time-based signatures, verify that the validAfter and validUntil fields are set to 0.\",\n                \"• If you are using a service, contact your service provider for their paymaster's validity.\",\n                \"\",\n                docsPath ? `Docs: ${docsPath}` : \"\"\n            ].join(\"\\n\"),\n            {\n                cause\n            }\n        )\n    }\n}\n\nexport type PaymasterValidationRevertedErrorType =\n    PaymasterValidationRevertedError & {\n        name: \"PaymasterValidationRevertedError\"\n    }\nexport class PaymasterValidationRevertedError extends BaseError {\n    static message = /aa33/\n    override name = \"PaymasterValidationRevertedError\"\n    constructor({\n        cause,\n        paymasterAndData,\n        docsPath\n    }: {\n        cause?: BaseError\n        paymasterAndData?: Hex\n        docsPath?: string\n    }) {\n        const paymaster = paymasterAndData\n            ? getAddressFromInitCodeOrPaymasterAndData(paymasterAndData)\n            : \"0x\"\n\n        super(\n            [\n                `The validatePaymasterUserOp function of the paymaster ${paymaster} either reverted or ran out of gas.`,\n                \"\",\n                \"Possible solutions:\",\n                \"• Verify that the verificationGasLimit is high enough to cover the validatePaymasterUserOp function's gas costs.\",\n                \"• If you are using your own paymaster contract, verify that the validatePaymasterUserOp function is implemented with the correct logic, and that the user operation is supposed to be valid.\",\n                \"• If you are using a paymaster service, and the user operation is well formed with a high enough verificationGasLimit, reach out to them.\",\n                \"• If you are not looking to use a paymaster to cover the gas fees, verify that the paymasterAndData field is not set.\",\n                \"\",\n                docsPath ? `Docs: ${docsPath}` : \"\"\n            ].join(\"\\n\"),\n            {\n                cause\n            }\n        )\n    }\n}\n\nexport type PaymasterDataRejectedErrorType = PaymasterDataRejectedError & {\n    name: \"PaymasterDataRejectedError\"\n}\nexport class PaymasterDataRejectedError extends BaseError {\n    static message = /aa34/\n    override name = \"PaymasterDataRejectedError\"\n    constructor({\n        cause,\n        paymasterAndData,\n        docsPath\n    }: {\n        cause?: BaseError\n        paymasterAndData?: Hex\n        docsPath?: string\n    }) {\n        const paymaster = paymasterAndData\n            ? getAddressFromInitCodeOrPaymasterAndData(paymasterAndData)\n            : \"0x\"\n\n        super(\n            [\n                `The validatePaymasterUserOp function of the paymaster ${paymaster} rejected paymasterAndData.`,\n                \"\",\n                \"Possible solutions:\",\n                \"• If you are using your own paymaster contract, verify that the user operation was correctly signed according to your implementation, and that the paymaster signature was correctly encoded in the paymasterAndData field of the user operation.\",\n                \"• If you are using a paymaster service, make sure you do not modify any of the fields of the user operation after the paymaster signs over it (except the signature field).\",\n                \"• If you are using a paymaster service and you have not modified any of the fields except the signature but you are still getting this error, reach out to them.\",\n                \"\",\n                docsPath ? `Docs: ${docsPath}` : \"\"\n            ].join(\"\\n\"),\n            {\n                cause\n            }\n        )\n    }\n}\n\nexport type PaymasterPostOpRevertedErrorType = PaymasterPostOpRevertedError & {\n    name: \"PaymasterPostOpRevertedError\"\n}\nexport class PaymasterPostOpRevertedError extends BaseError {\n    static message = /aa50/\n    override name = \"PaymasterPostOpRevertedError\"\n    constructor({\n        cause,\n        paymasterAndData,\n        docsPath\n    }: {\n        cause?: BaseError\n        paymasterAndData?: Hex\n        docsPath?: string\n    }) {\n        const paymaster = paymasterAndData\n            ? getAddressFromInitCodeOrPaymasterAndData(paymasterAndData)\n            : \"0x\"\n\n        super(\n            [\n                `The postOp function of the paymaster ${paymaster} reverted.`,\n                \"\",\n                \"Possible solutions:\",\n                \"• If you are using your own paymaster contract, verify that that you have correctly implemented the postOp function (if you are using one). If you do not intent to make use of the postOp function, make sure you do not set the context parameter in the paymaster's validatePaymasterUserOp function.\",\n                \"• If you are using a paymaster service and you see this error, reach out to them.\",\n                \"\",\n                docsPath ? `Docs: ${docsPath}` : \"\"\n            ].join(\"\\n\"),\n            {\n                cause\n            }\n        )\n    }\n}\n\nexport type InvalidPaymasterAndDataErrorType = InvalidPaymasterAndDataError & {\n    name: \"InvalidPaymasterAndDataError\"\n}\nexport class InvalidPaymasterAndDataError extends BaseError {\n    static message = /aa93/\n    override name = \"InvalidPaymasterAndDataError\"\n    constructor({\n        cause,\n        docsPath\n    }: {\n        cause?: BaseError\n        docsPath?: string\n    }) {\n        super(\n            [\n                \"The paymasterAndData field of the user operation is invalid.\",\n                \"\",\n                \"Possible solutions:\",\n                \"• Make sure you have either not set a value for the paymasterAndData, or that it is at least 20 bytes long.\",\n                \"• If you are using a paymaster service, reach out to them.\",\n                \"\",\n                docsPath ? `Docs: ${docsPath}` : \"\"\n            ].join(\"\\n\"),\n            {\n                cause\n            }\n        )\n    }\n}\n", "import { BaseError } from \"viem\"\n\nexport type InvalidBeneficiaryAddressErrorType =\n    InvalidBeneficiaryAddressError & {\n        name: \"InvalidBeneficiaryAddressError\"\n    }\nexport class InvalidBeneficiaryAddressError extends BaseError {\n    static message = /aa9[01]/\n    override name = \"InvalidBeneficiaryAddressError\"\n    constructor({\n        cause,\n        docsPath\n    }: {\n        cause?: BaseError\n        docsPath?: string\n    }) {\n        super(\n            [\n                \"The bundler did not set a beneficiary address when bundling the user operation.\",\n                \"\",\n                \"Possible solutions:\",\n                \"• If you encounter this error when running self-hosted bundler, make sure you have configured the bundler correctly.\",\n                \"• If you are using a bundler provider, reach out to them.\",\n                \"\",\n                docsPath ? `Docs: ${docsPath}` : \"\"\n            ].join(\"\\n\"),\n            {\n                cause\n            }\n        )\n    }\n}\n\nexport type InvalidAggregatorErrorType = InvalidAggregatorError & {\n    name: \"InvalidAggregatorError\"\n}\nexport class InvalidAggregatorError extends BaseError {\n    static message = /aa96/\n    override name = \"InvalidAggregatorError\"\n    constructor({\n        cause,\n        docsPath\n    }: {\n        cause?: BaseError\n        docsPath?: string\n    }) {\n        super(\n            [\n                \"The bundler tried to bundle the user operation with an invalid aggregator.\",\n                \"\",\n                \"Possible solutions:\",\n                \"• If you are using your own bundler, configure it to use a valid aggregator.\",\n                \"• If you are using a bundler provider, reach out to them.\",\n                \"\",\n                docsPath ? `Docs: ${docsPath}` : \"\"\n            ].join(\"\\n\"),\n            {\n                cause\n            }\n        )\n    }\n}\n", "import { BaseError } from \"viem\"\n\nexport type VerificationGasLimitTooLowErrorType =\n    VerificationGasLimitTooLowError & {\n        name: \"VerificationGasLimitTooLowError\"\n    }\nexport class VerificationGasLimitTooLowError extends BaseError {\n    static message = /aa4[01]/\n    override name = \"VerificationGasLimitTooLowError\"\n    constructor({\n        cause,\n        verificationGasLimit,\n        docsPath\n    }: {\n        cause?: BaseError\n        verificationGasLimit?: bigint\n        docsPath?: string\n    }) {\n        super(\n            [\n                `The smart account and paymaster verification exceeded the verificationGasLimit ${verificationGasLimit} set for the user operation.`,\n                \"\",\n                \"Possible solutions:\",\n                \"• Verify that the verificationGasLimit set for the user operation is high enough to cover the gas used during smart account and paymaster verification.\",\n                \"• If you are using the eth_estimateUserOperationGas or pm_sponsorUserOperation method from bundler provider to set user operation gas limits and the EntryPoint throws this error during submission, reach out to them.\",\n                \"\",\n                docsPath ? `Docs: ${docsPath}` : \"\"\n            ].join(\"\\n\"),\n            {\n                cause\n            }\n        )\n    }\n}\n\nexport type ActualGasCostTooHighErrorType = ActualGasCostTooHighError & {\n    name: \"ActualGasCostTooHighError\"\n}\nexport class ActualGasCostTooHighError extends BaseError {\n    static message = /aa51/\n    override name = \"ActualGasCostTooHighError\"\n    constructor({\n        cause,\n        docsPath\n    }: {\n        cause?: BaseError\n        docsPath?: string\n    }) {\n        super(\n            [\n                \"The actual gas cost of the user operation ended up being higher than the funds paid by the smart account or the paymaster.\",\n                \"\",\n                \"Possible solutions:\",\n                \"• If you encounter this error, try increasing the verificationGasLimit set for the user operation.\",\n                \"• If you are using the eth_estimateUserOperationGas or pm_sponsorUserOperation method from bundler provider to set user operation gas limits and the EntryPoint throws this error during submission, reach out to them.\",\n                \"\",\n                docsPath ? `Docs: ${docsPath}` : \"\"\n            ].join(\"\\n\"),\n            {\n                cause\n            }\n        )\n    }\n}\n\nexport type GasValuesOverflowErrorType = GasValuesOverflowError & {\n    name: \"GasValuesOverflowError\"\n}\nexport class GasValuesOverflowError extends BaseError {\n    static message = /aa94/\n    override name = \"GasValuesOverflowError\"\n    constructor({\n        cause,\n        docsPath\n    }: {\n        cause?: BaseError\n        docsPath?: string\n    }) {\n        super(\n            [\n                \"The gas limit values of the user operation overflowed, they must fit in uint160.\",\n                \"\",\n                docsPath ? `Docs: ${docsPath}` : \"\"\n            ].join(\"\\n\"),\n            {\n                cause\n            }\n        )\n    }\n}\n\nexport type BundlerOutOfGasErrorType = BundlerOutOfGasError & {\n    name: \"BundlerOutOfGasError\"\n}\nexport class BundlerOutOfGasError extends BaseError {\n    static message = /aa95/\n    override name = \"BundlerOutOfGasError\"\n    constructor({\n        cause,\n        docsPath\n    }: {\n        cause?: BaseError\n        docsPath?: string\n    }) {\n        super(\n            [\n                \"The bundler tried to bundle the user operation with the gas limit set too low.\",\n                \"\",\n                \"Possible solutions:\",\n                \"• If you are using your own bundler, configure it send gas limits properly.\",\n                \"• If you are using a bundler provider, reach out to them.\",\n                \"\",\n                docsPath ? `Docs: ${docsPath}` : \"\"\n            ].join(\"\\n\"),\n            {\n                cause\n            }\n        )\n    }\n}\n", "import {\n    type Address,\n    BaseError,\n    ExecutionRevertedError,\n    type ExecutionRevertedErrorType,\n    UnknownNodeError,\n    type UnknownNodeErrorType\n} from \"viem\"\nimport { SenderAlreadyDeployedError } from \"../../errors\"\nimport {\n    InitCodeDidNotDeploySenderError,\n    type InitCodeDidNotDeploySenderErrorType,\n    InitCodeRevertedError,\n    type InitCodeRevertedErrorType,\n    InvalidSmartAccountNonceError,\n    type InvalidSmartAccountNonceErrorType,\n    SenderAddressMismatchError,\n    type SenderAddressMismatchErrorType,\n    type SenderAlreadyDeployedErrorType,\n    SenderNotDeployedError,\n    type SenderNotDeployedErrorType,\n    SmartAccountInsufficientFundsError,\n    type SmartAccountInsufficientFundsErrorType,\n    SmartAccountSignatureValidityPeriodError,\n    type SmartAccountSignatureValidityPeriodErrorType,\n    SmartAccountValidationRevertedError,\n    type SmartAccountValidationRevertedErrorType\n} from \"../../errors/account\"\nimport {\n    PaymasterDataRejectedError,\n    type PaymasterDataRejectedErrorType,\n    PaymasterDepositTooLowError,\n    type PaymasterDepositTooLowErrorType,\n    PaymasterNotDeployedError,\n    type PaymasterNotDeployedErrorType,\n    PaymasterValidationRevertedError,\n    type PaymasterValidationRevertedErrorType,\n    PaymasterValidityPeriodError,\n    type PaymasterValidityPeriodErrorType\n} from \"../../errors/paymaster\"\nimport type {\n    EntryPoint,\n    GetEntryPointVersion,\n    UserOperation\n} from \"../../types\"\n\nexport type GetBundlerErrorParameters<entryPoint extends EntryPoint> = {\n    userOperation: Partial<UserOperation<GetEntryPointVersion<entryPoint>>>\n    entryPoint: Address\n}\n\nexport type GetBundlerErrorReturnType =\n    | ExecutionRevertedErrorType\n    | UnknownNodeErrorType\n    | SenderAlreadyDeployedErrorType\n    | InitCodeRevertedErrorType\n    | SenderAddressMismatchErrorType\n    | InitCodeDidNotDeploySenderErrorType\n    | SenderNotDeployedErrorType\n    | SmartAccountInsufficientFundsErrorType\n    | SmartAccountSignatureValidityPeriodErrorType\n    | SmartAccountValidationRevertedErrorType\n    | InvalidSmartAccountNonceErrorType\n    | PaymasterNotDeployedErrorType\n    | PaymasterDepositTooLowErrorType\n    | PaymasterValidityPeriodErrorType\n    | PaymasterValidationRevertedErrorType\n    | PaymasterDataRejectedErrorType\n\nexport function getBundlerError<entryPoint extends EntryPoint>(\n    err: BaseError,\n    args: GetBundlerErrorParameters<entryPoint>\n) {\n    const message = (err.details || \"\").toLowerCase()\n\n    const executionRevertedError =\n        err instanceof BaseError\n            ? err.walk(\n                  (e) =>\n                      (e as { code: number }).code ===\n                      ExecutionRevertedError.code\n              )\n            : err\n\n    if (executionRevertedError instanceof BaseError) {\n        return new ExecutionRevertedError({\n            cause: err,\n            message: executionRevertedError.details\n        }) as ExecutionRevertedErrorType\n    }\n\n    // TODO: Add validation Errors\n    if (args.userOperation.sender === undefined)\n        return new UnknownNodeError({ cause: err })\n    if (args.userOperation.nonce === undefined)\n        return new UnknownNodeError({ cause: err })\n\n    if (SenderAlreadyDeployedError.message.test(message)) {\n        return new SenderAlreadyDeployedError({\n            cause: err,\n            sender: args.userOperation.sender,\n            docsPath:\n                \"https://docs.pimlico.io/bundler/reference/entrypoint-errors/aa10\"\n        }) as SenderAlreadyDeployedErrorType\n    }\n\n    if (InitCodeRevertedError.message.test(message)) {\n        return new InitCodeRevertedError({\n            cause: err,\n            docsPath:\n                \"https://docs.pimlico.io/bundler/reference/entrypoint-errors/aa13\"\n        }) as InitCodeRevertedErrorType\n    }\n\n    if (SenderAddressMismatchError.message.test(message)) {\n        return new SenderAddressMismatchError({\n            cause: err,\n            sender: args.userOperation.sender,\n            docsPath:\n                \"https://docs.pimlico.io/bundler/reference/entrypoint-errors/aa14\"\n        }) as SenderAddressMismatchErrorType\n    }\n\n    if (InitCodeDidNotDeploySenderError.message.test(message)) {\n        return new InitCodeDidNotDeploySenderError({\n            cause: err,\n            sender: args.userOperation.sender,\n            docsPath:\n                \"https://docs.pimlico.io/bundler/reference/entrypoint-errors/aa15\"\n        }) as InitCodeDidNotDeploySenderErrorType\n    }\n\n    if (SenderNotDeployedError.message.test(message)) {\n        return new SenderNotDeployedError({\n            cause: err,\n            sender: args.userOperation.sender,\n            docsPath:\n                \"https://docs.pimlico.io/bundler/reference/entrypoint-errors/aa20\"\n        }) as SenderNotDeployedErrorType\n    }\n\n    if (SmartAccountInsufficientFundsError.message.test(message)) {\n        return new SmartAccountInsufficientFundsError({\n            cause: err,\n            sender: args.userOperation.sender,\n            docsPath:\n                \"https://docs.pimlico.io/bundler/reference/entrypoint-errors/aa21\"\n        }) as SmartAccountInsufficientFundsErrorType\n    }\n\n    if (SmartAccountSignatureValidityPeriodError.message.test(message)) {\n        return new SmartAccountSignatureValidityPeriodError({\n            cause: err,\n            docsPath:\n                \"https://docs.pimlico.io/bundler/reference/entrypoint-errors/aa22\"\n        }) as SmartAccountSignatureValidityPeriodErrorType\n    }\n\n    if (SmartAccountValidationRevertedError.message.test(message)) {\n        return new SmartAccountValidationRevertedError({\n            cause: err,\n            sender: args.userOperation.sender,\n            docsPath:\n                \"https://docs.pimlico.io/bundler/reference/entrypoint-errors/aa23\"\n        }) as SmartAccountValidationRevertedErrorType\n    }\n\n    if (InvalidSmartAccountNonceError.message.test(message)) {\n        return new InvalidSmartAccountNonceError({\n            cause: err,\n            sender: args.userOperation.sender,\n            nonce: args.userOperation.nonce,\n            docsPath:\n                \"https://docs.pimlico.io/bundler/reference/entrypoint-errors/aa25\"\n        }) as InvalidSmartAccountNonceErrorType\n    }\n\n    if (PaymasterNotDeployedError.message.test(message)) {\n        return new PaymasterNotDeployedError({\n            cause: err,\n            paymasterAndData: args.userOperation.paymasterAndData,\n            docsPath:\n                \"https://docs.pimlico.io/bundler/reference/entrypoint-errors/aa30\"\n        }) as PaymasterNotDeployedErrorType\n    }\n\n    if (PaymasterDepositTooLowError.message.test(message)) {\n        return new PaymasterDepositTooLowError({\n            cause: err,\n            paymasterAndData: args.userOperation.paymasterAndData,\n            docsPath:\n                \"https://docs.pimlico.io/bundler/reference/entrypoint-errors/aa31\"\n        }) as PaymasterDepositTooLowErrorType\n    }\n\n    if (PaymasterValidityPeriodError.message.test(message)) {\n        return new PaymasterValidityPeriodError({\n            cause: err,\n            paymasterAndData: args.userOperation.paymasterAndData,\n            docsPath:\n                \"https://docs.pimlico.io/bundler/reference/entrypoint-errors/aa32\"\n        }) as PaymasterValidityPeriodErrorType\n    }\n\n    if (PaymasterValidationRevertedError.message.test(message)) {\n        return new PaymasterValidationRevertedError({\n            cause: err,\n            paymasterAndData: args.userOperation.paymasterAndData,\n            docsPath:\n                \"https://docs.pimlico.io/bundler/reference/entrypoint-errors/aa33\"\n        }) as PaymasterValidationRevertedErrorType\n    }\n\n    if (PaymasterDataRejectedError.message.test(message)) {\n        return new PaymasterDataRejectedError({\n            cause: err,\n            paymasterAndData: args.userOperation.paymasterAndData,\n            docsPath:\n                \"https://docs.pimlico.io/bundler/reference/entrypoint-errors/aa34\"\n        }) as PaymasterDataRejectedErrorType\n    }\n\n    return new UnknownNodeError({ cause: err }) as UnknownNodeErrorType\n}\n", "import { BaseError, UnknownNodeError } from \"viem\"\nimport type { SendUserOperationParameters } from \"../../actions/bundler/sendUserOperation\"\nimport { SendUserOperationError } from \"../../errors\"\nimport type { EntryPoint } from \"../../types/entrypoint\"\nimport {\n    type GetBundlerErrorParameters,\n    getBundlerError\n} from \"./getBundlerError\"\n\nexport function getSendUserOperationError<entryPoint extends EntryPoint>(\n    err: BaseError,\n    args: SendUserOperationParameters<entryPoint>\n) {\n    const cause = (() => {\n        const cause = getBundlerError(\n            err as BaseError,\n            args as GetBundlerErrorParameters<entryPoint>\n        )\n        if (cause instanceof UnknownNodeError) return err as BaseError\n        return cause\n    })()\n\n    throw new SendUserOperationError(cause, {\n        ...args\n    })\n}\n", "import type { Account, BaseError, Chain, Client, Hash, Transport } from \"viem\"\nimport type { BundlerClient } from \"../../clients/createBundlerClient\"\nimport type { Prettify } from \"../../types/\"\nimport type { BundlerRpcSchema } from \"../../types/bundler\"\nimport type { EntryPoint, GetEntryPointVersion } from \"../../types/entrypoint\"\nimport type {\n    UserOperation,\n    UserOperationWithBigIntAsHex\n} from \"../../types/userOperation\"\nimport { deepHexlify } from \"../../utils/deepHexlify\"\nimport { getSendUserOperationError } from \"../../utils/errors/getSendUserOperationError\"\n\nexport type SendUserOperationParameters<entryPoint extends EntryPoint> = {\n    userOperation: UserOperation<GetEntryPointVersion<entryPoint>>\n    entryPoint: entryPoint\n}\n\n/**\n * Sends user operation to the bundler\n *\n * - Docs: https://docs.pimlico.io/permissionless/reference/bundler-actions/sendUserOperation\n *\n * @param client {@link BundlerClient} that you created using viem's createClient and extended it with bundlerActions.\n * @param args {@link SendUserOperationParameters}.\n * @returns UserOpHash that you can use to track user operation as {@link Hash}.\n *\n * @example\n * import { createClient } from \"viem\"\n * import { sendUserOperation } from \"permissionless/actions\"\n *\n * const bundlerClient = createClient({\n *      chain: goerli,\n *      transport: http(BUNDLER_URL)\n * })\n *\n * const userOpHash = sendUserOperation(bundlerClient, {\n *      userOperation: signedUserOperation,\n *      entryPoint: entryPoint\n * })\n *\n * // Return '0xe9fad2cd67f9ca1d0b7a6513b2a42066784c8df938518da2b51bb8cc9a89ea34'\n */\nexport const sendUserOperation = async <\n    entryPoint extends EntryPoint,\n    TTransport extends Transport = Transport,\n    TChain extends Chain | undefined = Chain | undefined,\n    TAccount extends Account | undefined = Account | undefined\n>(\n    client: Client<TTransport, TChain, TAccount, BundlerRpcSchema<entryPoint>>,\n    args: Prettify<SendUserOperationParameters<entryPoint>>\n): Promise<Hash> => {\n    const { userOperation, entryPoint } = args\n\n    try {\n        const userOperationHash = await client.request({\n            method: \"eth_sendUserOperation\",\n            params: [\n                deepHexlify(userOperation) as UserOperationWithBigIntAsHex<\n                    GetEntryPointVersion<entryPoint>\n                >,\n                entryPoint\n            ]\n        })\n\n        return userOperationHash\n    } catch (err) {\n        throw getSendUserOperationError(\n            err as BaseError,\n            args as SendUserOperationParameters<entryPoint>\n        )\n    }\n}\n", "import { BaseError, UnknownNodeError } from \"viem\"\nimport type { EstimateUserOperationGasParameters } from \"../../actions/bundler/estimateUserOperationGas\"\nimport {\n    EstimateUserOperationGasError,\n    type EstimateUserOperationGasErrorType\n} from \"../../errors/estimateUserOperationGas\"\nimport { type ErrorType } from \"../../errors/utils\"\nimport type { EntryPoint } from \"../../types/entrypoint\"\nimport {\n    type GetBundlerErrorParameters,\n    type GetBundlerErrorReturnType,\n    getBundlerError\n} from \"./getBundlerError\"\n\nexport type GetEstimateUserOperationGasErrorReturnType<\n    entryPoint extends EntryPoint,\n    cause = ErrorType\n> = Omit<EstimateUserOperationGasErrorType<entryPoint>, \"cause\"> & {\n    cause: cause | GetBundlerErrorReturnType\n}\n\nexport function getEstimateUserOperationGasError<\n    err extends ErrorType<string>,\n    entryPoint extends EntryPoint\n>(error: err, args: EstimateUserOperationGasParameters<entryPoint>) {\n    const cause = (() => {\n        const cause = getBundlerError(\n            // biome-ignore lint/complexity/noBannedTypes: <explanation>\n            error as {} as BaseError,\n            args as GetBundlerErrorParameters<entryPoint>\n        )\n        // biome-ignore lint/complexity/noBannedTypes: <explanation>\n        if (cause instanceof UnknownNodeError) return error as {} as BaseError\n        return cause\n    })()\n\n    throw new EstimateUserOperationGasError(cause, {\n        ...args\n    }) as GetEstimateUserOperationGasErrorReturnType<entryPoint, err>\n}\n", "import {\n    type Account,\n    BaseError,\n    type Chain,\n    type Client,\n    type Hex,\n    type Transport\n} from \"viem\"\nimport type { PartialBy } from \"viem/types/utils\"\nimport type { BundlerClient } from \"../../clients/createBundlerClient\"\nimport type { Prettify } from \"../../types/\"\nimport type { BundlerRpcSchema, StateOverrides } from \"../../types/bundler\"\nimport type { EntryPoint, GetEntryPointVersion } from \"../../types/entrypoint\"\nimport type { UserOperation } from \"../../types/userOperation\"\nimport { getEntryPointVersion } from \"../../utils\"\nimport { deepHexlify } from \"../../utils/deepHexlify\"\nimport {\n    type GetEstimateUserOperationGasErrorReturnType,\n    getEstimateUserOperationGasError\n} from \"../../utils/errors/getEstimateUserOperationGasError\"\n\nexport type EstimateUserOperationGasParameters<entryPoint extends EntryPoint> =\n    {\n        userOperation: GetEntryPointVersion<entryPoint> extends \"v0.6\"\n            ? PartialBy<\n                  UserOperation<\"v0.6\">,\n                  \"callGasLimit\" | \"preVerificationGas\" | \"verificationGasLimit\"\n              >\n            : PartialBy<\n                  UserOperation<\"v0.7\">,\n                  | \"callGasLimit\"\n                  | \"preVerificationGas\"\n                  | \"verificationGasLimit\"\n                  | \"paymasterVerificationGasLimit\"\n                  | \"paymasterPostOpGasLimit\"\n              >\n        entryPoint: entryPoint\n    }\n\nexport type EstimateUserOperationGasReturnType<entryPoint extends EntryPoint> =\n    GetEntryPointVersion<entryPoint> extends \"v0.6\"\n        ? {\n              preVerificationGas: bigint\n              verificationGasLimit: bigint\n              callGasLimit: bigint\n          }\n        : {\n              preVerificationGas: bigint\n              verificationGasLimit: bigint\n              callGasLimit: bigint\n              paymasterVerificationGasLimit?: bigint\n              paymasterPostOpGasLimit?: bigint\n          }\n\nexport type EstimateUserOperationErrorType<entryPoint extends EntryPoint> =\n    GetEstimateUserOperationGasErrorReturnType<entryPoint>\n\n/**\n * Estimates preVerificationGas, verificationGasLimit and callGasLimit for user operation\n *\n * - Docs: https://docs.pimlico.io/permissionless/reference/bundler-actions/estimateUserOperationGas\n *\n * @param client {@link BundlerClient} that you created using viem's createClient and extended it with bundlerActions.\n * @param args {@link EstimateUserOperationGasParameters}\n * @returns preVerificationGas, verificationGasLimit and callGasLimit as {@link EstimateUserOperationGasReturnType}\n *\n *\n * @example\n * import { createClient } from \"viem\"\n * import { estimateUserOperationGas } from \"permissionless/actions\"\n *\n * const bundlerClient = createClient({\n *      chain: goerli,\n *      transport: http(BUNDLER_URL)\n * })\n *\n * const gasParameters = estimateUserOperationGas(bundlerClient, {\n *      serOperation: signedUserOperation,\n *      entryPoint: entryPoint\n * })\n *\n * // Return {preVerificationGas: 43492n, verificationGasLimit: 59436n, callGasLimit: 9000n}\n *\n */\nexport const estimateUserOperationGas = async <\n    entryPoint extends EntryPoint,\n    TTransport extends Transport = Transport,\n    TChain extends Chain | undefined = Chain | undefined,\n    TAccount extends Account | undefined = Account | undefined\n>(\n    client: Client<TTransport, TChain, TAccount, BundlerRpcSchema<entryPoint>>,\n    args: Prettify<EstimateUserOperationGasParameters<entryPoint>>,\n    stateOverrides?: StateOverrides\n): Promise<EstimateUserOperationGasReturnType<entryPoint>> => {\n    const { userOperation, entryPoint } = args\n\n    const userOperationWithBigIntAsHex = deepHexlify(userOperation)\n    const stateOverridesWithBigIntAsHex = deepHexlify(stateOverrides)\n\n    try {\n        const response = await client.request({\n            method: \"eth_estimateUserOperationGas\",\n            params: stateOverrides\n                ? [\n                      userOperationWithBigIntAsHex,\n                      entryPoint,\n                      stateOverridesWithBigIntAsHex\n                  ]\n                : [userOperationWithBigIntAsHex, entryPoint]\n        })\n\n        const entryPointVersion = getEntryPointVersion(entryPoint)\n\n        if (entryPointVersion === \"v0.6\") {\n            const responseV06 = response as {\n                preVerificationGas: Hex\n                verificationGasLimit: Hex\n                callGasLimit: Hex\n            }\n\n            return {\n                preVerificationGas: BigInt(responseV06.preVerificationGas || 0),\n                verificationGasLimit: BigInt(\n                    responseV06.verificationGasLimit || 0\n                ),\n                callGasLimit: BigInt(responseV06.callGasLimit || 0)\n            } as EstimateUserOperationGasReturnType<entryPoint>\n        }\n\n        const responseV07 = response as {\n            preVerificationGas: Hex\n            verificationGasLimit: Hex\n            callGasLimit: Hex\n            paymasterVerificationGasLimit?: Hex\n            paymasterPostOpGasLimit?: Hex\n        }\n\n        return {\n            preVerificationGas: BigInt(responseV07.preVerificationGas || 0),\n            verificationGasLimit: BigInt(responseV07.verificationGasLimit || 0),\n            callGasLimit: BigInt(responseV07.callGasLimit || 0),\n            paymasterVerificationGasLimit:\n                responseV07.paymasterVerificationGasLimit\n                    ? BigInt(responseV07.paymasterVerificationGasLimit)\n                    : undefined,\n            paymasterPostOpGasLimit: responseV07.paymasterPostOpGasLimit\n                ? BigInt(responseV07.paymasterPostOpGasLimit)\n                : undefined\n        } as EstimateUserOperationGasReturnType<entryPoint>\n    } catch (err) {\n        throw getEstimateUserOperationGasError(err as BaseError, args)\n    }\n}\n", "import type { Account, Address, Chain, Client, Hash, Transport } from \"viem\"\nimport type { BundlerClient } from \"../../clients/createBundlerClient\"\nimport type { Prettify } from \"../../types/\"\nimport type { BundlerRpcSchema } from \"../../types/bundler\"\nimport type { EntryPoint, GetEntryPointVersion } from \"../../types/entrypoint\"\nimport type { UserOperation } from \"../../types/userOperation\"\nimport { ENTRYPOINT_ADDRESS_V06 } from \"../../utils/getEntryPointVersion\"\n\nexport type GetUserOperationByHashParameters = {\n    hash: Hash\n}\n\nexport type GetUserOperationByHashReturnType<entryPoint extends EntryPoint> = {\n    userOperation: UserOperation<GetEntryPointVersion<entryPoint>>\n    entryPoint: Address\n    transactionHash: Hash\n    blockHash: Hash\n    blockNumber: bigint\n}\n\n/**\n * Returns the user operation from userOpHash\n *\n * - Docs: https://docs.pimlico.io/permissionless/reference/bundler-actions/getUserOperationByHash\n *\n * @param client {@link BundlerClient} that you created using viem's createClient and extended it with bundlerActions.\n * @param args {@link GetUserOperationByHashParameters} UserOpHash that was returned by {@link sendUserOperation}\n * @returns userOperation along with entryPoint, transactionHash, blockHash, blockNumber if found or null\n *\n *\n * @example\n * import { createClient } from \"viem\"\n * import { getUserOperationByHash } from \"permissionless/actions\"\n *\n * const bundlerClient = createClient({\n *      chain: goerli,\n *      transport: http(BUNDLER_URL)\n * })\n *\n * getUserOperationByHash(bundlerClient, {hash: userOpHash})\n *\n */\nexport const getUserOperationByHash = async <\n    entryPoint extends EntryPoint,\n    TTransport extends Transport = Transport,\n    TChain extends Chain | undefined = Chain | undefined,\n    TAccount extends Account | undefined = Account | undefined\n>(\n    client: Client<TTransport, TChain, TAccount, BundlerRpcSchema<entryPoint>>,\n    { hash }: Prettify<GetUserOperationByHashParameters>\n): Promise<Prettify<GetUserOperationByHashReturnType<entryPoint>> | null> => {\n    const params: [Hash] = [hash]\n\n    const response = await client.request({\n        method: \"eth_getUserOperationByHash\",\n        params\n    })\n\n    if (!response) return null\n\n    const {\n        userOperation,\n        entryPoint: entryPointAddress,\n        transactionHash,\n        blockHash,\n        blockNumber\n    } = response\n\n    return {\n        userOperation: (entryPointAddress === ENTRYPOINT_ADDRESS_V06\n            ? {\n                  ...userOperation,\n                  nonce: BigInt(userOperation.nonce),\n                  callGasLimit: BigInt(userOperation.callGasLimit),\n                  verificationGasLimit: BigInt(\n                      userOperation.verificationGasLimit\n                  ),\n                  preVerificationGas: BigInt(userOperation.preVerificationGas),\n                  maxFeePerGas: BigInt(userOperation.maxFeePerGas),\n                  maxPriorityFeePerGas: BigInt(\n                      userOperation.maxPriorityFeePerGas\n                  )\n              }\n            : {\n                  ...userOperation,\n                  nonce: BigInt(userOperation.nonce),\n                  callGasLimit: BigInt(userOperation.callGasLimit),\n                  verificationGasLimit: BigInt(\n                      userOperation.verificationGasLimit\n                  ),\n                  preVerificationGas: BigInt(userOperation.preVerificationGas),\n                  maxFeePerGas: BigInt(userOperation.maxFeePerGas),\n                  maxPriorityFeePerGas: BigInt(\n                      userOperation.maxPriorityFeePerGas\n                  ),\n                  paymasterVerificationGasLimit:\n                      userOperation.paymasterVerificationGasLimit\n                          ? BigInt(userOperation.paymasterVerificationGasLimit)\n                          : undefined,\n                  paymasterPostOpGasLimit:\n                      userOperation.paymasterVerificationGasLimit\n                          ? BigInt(userOperation.paymasterPostOpGasLimit)\n                          : undefined\n              }) as UserOperation<GetEntryPointVersion<entryPoint>>,\n        entryPoint: entryPointAddress,\n        transactionHash: transactionHash,\n        blockHash: blockHash,\n        blockNumber: BigInt(blockNumber)\n    }\n}\n", "import type {\n    Account,\n    Address,\n    Chain,\n    Client,\n    Hash,\n    Hex,\n    Transport\n} from \"viem\"\nimport type { BundlerClient } from \"../../clients/createBundlerClient\"\nimport type { Prettify } from \"../../types\"\nimport type { BundlerRpcSchema } from \"../../types/bundler\"\nimport type { EntryPoint } from \"../../types/entrypoint\"\nimport type { TStatus } from \"../../types/userOperation\"\nimport { transactionReceiptStatus } from \"../../utils/deepHexlify\"\n\nexport type GetUserOperationReceiptParameters = {\n    hash: Hash\n}\n\nexport type GetUserOperationReceiptReturnType = {\n    userOpHash: Hash\n    sender: Address\n    nonce: bigint\n    actualGasUsed: bigint\n    actualGasCost: bigint\n    success: boolean\n    receipt: {\n        transactionHash: Hex\n        transactionIndex: bigint\n        blockHash: Hash\n        blockNumber: bigint\n        from: Address\n        to: Address | null\n        cumulativeGasUsed: bigint\n        status: TStatus\n        gasUsed: bigint\n        contractAddress: Address | null\n        logsBloom: Hex\n        effectiveGasPrice: bigint\n    }\n    logs: {\n        data: Hex\n        blockNumber: bigint\n        blockHash: Hash\n        transactionHash: Hash\n        logIndex: bigint\n        transactionIndex: bigint\n        address: Address\n        topics: Hex[]\n    }[]\n}\n\n/**\n * Returns the user operation receipt from userOpHash\n *\n * - Docs: https://docs.pimlico.io/permissionless/reference/bundler-actions/getUserOperationReceipt\n *\n * @param client {@link BundlerClient} that you created using viem's createClient and extended it with bundlerActions.\n * @param args {@link GetUserOperationReceiptParameters} UserOpHash that was returned by {@link sendUserOperation}\n * @returns user operation receipt {@link GetUserOperationReceiptReturnType} if found or null\n *\n *\n * @example\n * import { createClient } from \"viem\"\n * import { getUserOperationReceipt } from \"permissionless/actions\"\n *\n * const bundlerClient = createClient({\n *      chain: goerli,\n *      transport: http(BUNDLER_URL)\n * })\n *\n * getUserOperationReceipt(bundlerClient, {hash: userOpHash})\n *\n */\nexport const getUserOperationReceipt = async <\n    entryPoint extends EntryPoint,\n    TTransport extends Transport = Transport,\n    TChain extends Chain | undefined = Chain | undefined,\n    TAccount extends Account | undefined = Account | undefined\n>(\n    client: Client<TTransport, TChain, TAccount, BundlerRpcSchema<entryPoint>>,\n    { hash }: Prettify<GetUserOperationReceiptParameters>\n): Promise<Prettify<GetUserOperationReceiptReturnType> | null> => {\n    const params: [Hash] = [hash]\n\n    const response = await client.request({\n        method: \"eth_getUserOperationReceipt\",\n        params\n    })\n\n    if (!response) return null\n\n    const userOperationReceipt: GetUserOperationReceiptReturnType = {\n        userOpHash: response.userOpHash,\n        sender: response.sender,\n        nonce: BigInt(response.nonce),\n        actualGasUsed: BigInt(response.actualGasUsed),\n        actualGasCost: BigInt(response.actualGasCost),\n        success: response.success,\n        receipt: {\n            transactionHash: response.receipt.transactionHash,\n            transactionIndex: BigInt(response.receipt.transactionIndex),\n            blockHash: response.receipt.blockHash,\n            blockNumber: BigInt(response.receipt.blockNumber),\n            from: response.receipt.from,\n            to: response.receipt.to,\n            cumulativeGasUsed: BigInt(response.receipt.cumulativeGasUsed),\n            status: transactionReceiptStatus[response.receipt.status],\n            gasUsed: BigInt(response.receipt.gasUsed),\n            contractAddress: response.receipt.contractAddress,\n            logsBloom: response.receipt.logsBloom,\n            effectiveGasPrice: BigInt(response.receipt.effectiveGasPrice)\n        },\n        logs: response.logs.map((log) => ({\n            data: log.data,\n            blockNumber: BigInt(log.blockNumber),\n            blockHash: log.blockHash,\n            transactionHash: log.transactionHash,\n            logIndex: BigInt(log.logIndex),\n            transactionIndex: BigInt(log.transactionIndex),\n            address: log.address,\n            topics: log.topics\n        }))\n    }\n\n    return userOperationReceipt\n}\n", "import type { Account, Chain, Client, Transport } from \"viem\"\nimport type { BundlerClient } from \"../../clients/createBundlerClient\"\nimport type { BundlerRpcSchema } from \"../../types/bundler\"\nimport type { EntryPoint } from \"../../types/entrypoint\"\n\n/**\n * Returns the supported entrypoints by the bundler service\n *\n * - Docs: https://docs.pimlico.io/permissionless/reference/bundler-actions/supportedEntryPoints\n *\n * @param client {@link BundlerClient} that you created using viem's createClient and extended it with bundlerActions.\n * @returns Supported entryPoints\n *\n *\n * @example\n * import { createClient } from \"viem\"\n * import { supportedEntryPoints } from \"permissionless/actions\"\n *\n * const bundlerClient = createClient({\n *      chain: goerli,\n *      transport: http(BUNDLER_URL)\n * })\n *\n * const entryPointsSupported = supportedEntryPoints(bundlerClient)\n * // Return ['0x5FF137D4b0FDCD49DcA30c7CF57E578a026d2789']\n *\n */\nexport const supportedEntryPoints = async <\n    entryPoint extends EntryPoint,\n    TTransport extends Transport = Transport,\n    TChain extends Chain | undefined = Chain | undefined,\n    TAccount extends Account | undefined = Account | undefined\n>(\n    client: Client<TTransport, TChain, TAccount, BundlerRpcSchema<entryPoint>>\n): Promise<EntryPoint[]> => {\n    return client.request({\n        method: \"eth_supportedEntryPoints\",\n        params: []\n    })\n}\n", "import type { MaybePromise } from \"viem/types/utils\"\n\n// biome-ignore lint/suspicious/noExplicitAny: it's a recursive function, so it's hard to type\ntype Callback = ((...args: any[]) => any) | undefined\ntype Callbacks = Record<string, Callback>\n\nexport const listenersCache = /*#__PURE__*/ new Map<\n    string,\n    { id: number; fns: Callbacks }[]\n>()\nexport const cleanupCache = /*#__PURE__*/ new Map<string, () => void>()\n\ntype EmitFunction<TCallbacks extends Callbacks> = (\n    emit: TCallbacks\n    // biome-ignore lint/suspicious/noConfusingVoidType: <explanation>\n) => MaybePromise<void | (() => void)>\n\nlet callbackCount = 0\n\n/**\n * @description Sets up an observer for a given function. If another function\n * is set up under the same observer id, the function will only be called once\n * for both instances of the observer.\n */\nexport function observe<TCallbacks extends Callbacks>(\n    observerId: string,\n    callbacks: TCallbacks,\n    fn: EmitFunction<TCallbacks>\n) {\n    const callbackId = ++callbackCount\n\n    const getListeners = () => listenersCache.get(observerId) || []\n\n    const unsubscribe = () => {\n        const listeners = getListeners()\n        listenersCache.set(\n            observerId,\n            // biome-ignore lint/suspicious/noExplicitAny: it's a recursive function, so it's hard to type\n            listeners.filter((cb: any) => cb.id !== callbackId)\n        )\n    }\n\n    const unwatch = () => {\n        const cleanup = cleanupCache.get(observerId)\n        if (getListeners().length === 1 && cleanup) cleanup()\n        unsubscribe()\n    }\n\n    const listeners = getListeners()\n    listenersCache.set(observerId, [\n        ...listeners,\n        { id: callbackId, fns: callbacks }\n    ])\n\n    if (listeners && listeners.length > 0) return unwatch\n\n    const emit: TCallbacks = {} as TCallbacks\n    for (const key in callbacks) {\n        emit[key] = ((\n            ...args: Parameters<NonNullable<TCallbacks[keyof TCallbacks]>>\n        ) => {\n            const listeners = getListeners()\n            if (listeners.length === 0) return\n            for (const listener of listeners) {\n                listener.fns[key]?.(...args)\n            }\n        }) as TCallbacks[Extract<keyof TCallbacks, string>]\n    }\n\n    const cleanup = fn(emit)\n    if (typeof cleanup === \"function\") cleanupCache.set(observerId, cleanup)\n\n    return unwatch\n}\n", "import {\n    type Account,\n    BaseError,\n    type Chain,\n    type Client,\n    type Hash,\n    type Transport,\n    stringify\n} from \"viem\"\nimport { getAction } from \"viem/utils\"\nimport type { Prettify } from \"../../types/\"\nimport { observe } from \"../../utils/observe\"\nimport {\n    type GetUserOperationReceiptReturnType,\n    getUserOperationReceipt\n} from \"./getUserOperationReceipt\"\n\nexport class WaitForUserOperationReceiptTimeoutError extends BaseError {\n    override name = \"WaitForUserOperationReceiptTimeoutError\"\n    constructor({ hash }: { hash: Hash }) {\n        super(\n            `Timed out while waiting for transaction with hash \"${hash}\" to be confirmed.`\n        )\n    }\n}\n\nexport type WaitForUserOperationReceiptParameters = {\n    /** The hash of the transaction. */\n    hash: Hash\n    /**\n     * Polling frequency (in ms). Defaults to the client's pollingInterval config.\n     * @default client.pollingInterval\n     */\n    pollingInterval?: number\n    /** Optional timeout (in milliseconds) to wait before stopping polling. */\n    timeout?: number\n}\n\n/**\n * Waits for the User Operation to be included on a [Block](https://viem.sh/docs/glossary/terms.html#block) (one confirmation), and then returns the [User Operation Receipt](https://docs.pimlico.io/permissionless/reference/bundler-actions/getUserOperationReceipt).\n *\n * - Docs: https://docs.pimlico.io/permissionless/reference/bundler-actions/waitForUserOperationReceipt\n *\n * @param client - Bundler Client to use\n * @param parameters - {@link WaitForUserOperationReceiptParameters}\n * @returns The transaction receipt. {@link GetUserOperationReceiptReturnType}\n *\n * @example\n * import { createBundlerClient, waitForUserOperationReceipt, http } from 'viem'\n * import { mainnet } from 'viem/chains'\n *\n * const client = createBundlerClient({\n *   chain: mainnet,\n *   transport: http(),\n * })\n * const userOperationReceipt = await waitForUserOperationReceipt(client, {\n *   hash: '0x4ca7ee652d57678f26e887c149ab0735f41de37bcad58c9f6d3ed5824f15b74d',\n * })\n */\nexport const waitForUserOperationReceipt = <\n    TTransport extends Transport = Transport,\n    TChain extends Chain | undefined = Chain | undefined,\n    TAccount extends Account | undefined = Account | undefined\n>(\n    bundlerClient: Client<TTransport, TChain, TAccount>,\n    {\n        hash,\n        pollingInterval = bundlerClient.pollingInterval,\n        timeout\n    }: Prettify<WaitForUserOperationReceiptParameters>\n): Promise<Prettify<GetUserOperationReceiptReturnType>> => {\n    const observerId = stringify([\n        \"waitForUserOperationReceipt\",\n        bundlerClient.uid,\n        hash\n    ])\n\n    let userOperationReceipt: GetUserOperationReceiptReturnType\n\n    return new Promise((resolve, reject) => {\n        const unobserve = observe(\n            observerId,\n            { resolve, reject },\n            async (emit) => {\n                let timeoutTimer: ReturnType<typeof setTimeout>\n\n                const _removeInterval = setInterval(async () => {\n                    const done = (fn: () => void) => {\n                        clearInterval(_removeInterval)\n                        fn()\n                        unobserve()\n                        if (timeout) clearTimeout(timeoutTimer)\n                    }\n                    try {\n                        const _userOperationReceipt = await getAction(\n                            bundlerClient,\n                            getUserOperationReceipt,\n                            \"getUserOperationReceipt\"\n                        )({ hash })\n\n                        if (_userOperationReceipt !== null) {\n                            userOperationReceipt = _userOperationReceipt\n                        }\n\n                        if (userOperationReceipt) {\n                            done(() => emit.resolve(userOperationReceipt))\n                            return\n                        }\n                    } catch (err) {\n                        done(() => emit.reject(err))\n                        return\n                    }\n                }, pollingInterval)\n\n                if (timeout) {\n                    timeoutTimer = setTimeout(() => {\n                        clearInterval(_removeInterval)\n                        unobserve()\n                        reject(\n                            new WaitForUserOperationReceiptTimeoutError({\n                                hash\n                            })\n                        )\n                        clearTimeout(timeoutTimer)\n                    }, timeout)\n                }\n            }\n        )\n    })\n}\n", "import type { Client, Hash } from \"viem\"\nimport { chainId } from \"../../actions/bundler/chainId\"\nimport {\n    type EstimateUserOperationGasParameters,\n    type EstimateUserOperationGasReturnType,\n    estimateUserOperationGas\n} from \"../../actions/bundler/estimateUserOperationGas\"\nimport {\n    type GetUserOperationByHashParameters,\n    type GetUserOperationByHashReturnType,\n    getUserOperationByHash\n} from \"../../actions/bundler/getUserOperationByHash\"\nimport {\n    type GetUserOperationReceiptParameters,\n    type GetUserOperationReceiptReturnType,\n    getUserOperationReceipt\n} from \"../../actions/bundler/getUserOperationReceipt\"\nimport {\n    type SendUserOperationParameters,\n    sendUserOperation\n} from \"../../actions/bundler/sendUserOperation\"\nimport { supportedEntryPoints } from \"../../actions/bundler/supportedEntryPoints\"\nimport {\n    type WaitForUserOperationReceiptParameters,\n    waitForUserOperationReceipt\n} from \"../../actions/bundler/waitForUserOperationReceipt\"\nimport type { Prettify } from \"../../types/\"\nimport type { StateOverrides } from \"../../types/bundler\"\nimport type { EntryPoint } from \"../../types/entrypoint\"\nimport type { BundlerClient } from \"../createBundlerClient\"\n\nexport type BundlerActions<entryPoint extends EntryPoint> = {\n    /**\n     *\n     * Sends user operation to the bundler\n     *\n     * - Docs: https://docs.pimlico.io/permissionless/reference/bundler-actions/sendUserOperation\n     *\n     * @param args {@link SendUserOperationParameters}.\n     * @returns UserOpHash that you can use to track user operation as {@link Hash}.\n     *\n     * @example\n     * import { createClient } from \"viem\"\n     * import { bundlerActions } from \"permissionless\"\n     *\n     * const bundlerClient = createClient({\n     *      chain: goerli,\n     *      transport: http(\"https://api.pimlico.io/v2/goerli/rpc?apikey=YOUR_API_KEY_HERE\")\n     * }).extend(bundlerActions)\n     *\n     * const userOpHash = await bundlerClient.sendUserOperation({\n     *      userOperation: signedUserOperation,\n     *      entryPoint: entryPoint\n     * })\n     *\n     * // Return '0xe9fad2cd67f9ca1d0b7a6513b2a42066784c8df938518da2b51bb8cc9a89ea34'\n     */\n    sendUserOperation: (\n        args: Prettify<\n            Omit<SendUserOperationParameters<entryPoint>, \"entryPoint\">\n        >\n    ) => Promise<Hash>\n    /**\n     *\n     * Estimates preVerificationGas, verificationGasLimit and callGasLimit for user operation\n     *\n     * - Docs: https://docs.pimlico.io/permissionless/reference/bundler-actions/estimateUserOperationGas\n     *\n     * @param args {@link EstimateUserOperationGasParameters}\n     * @returns preVerificationGas, verificationGasLimit and callGasLimit as {@link EstimateUserOperationGasReturnType}\n     *\n     * @example\n     * import { createClient } from \"viem\"\n     * import { bundlerActions } from \"permissionless\"\n     *\n     * const bundlerClient = createClient({\n     *      chain: goerli,\n     *      transport: http(BUNDLER_URL)\n     * }).extend(bundlerActions)\n     *\n     * const gasParameters = await bundlerClient.estimateUserOperationGas({\n     *     userOperation: signedUserOperation,\n     *    entryPoint: entryPoint\n     * })\n     *\n     * // Return {preVerificationGas: 43492n, verificationGasLimit: 59436n, callGasLimit: 9000n}\n     */\n    estimateUserOperationGas: (\n        args: Prettify<\n            Omit<EstimateUserOperationGasParameters<entryPoint>, \"entryPoint\">\n        >,\n        stateOverrides?: StateOverrides\n    ) => Promise<Prettify<EstimateUserOperationGasReturnType<entryPoint>>>\n    /**\n     *\n     * Returns the supported entrypoints by the bundler service\n     *\n     * - Docs: https://docs.pimlico.io/permissionless/reference/bundler-actions/supportedEntryPoints\n     *\n     * @returns Supported entryPoints\n     *\n     * @example\n     * import { createClient } from \"viem\"\n     * import { bundlerActions } from \"permissionless\"\n     *\n     * const bundlerClient = createClient({\n     *      chain: goerli,\n     *      transport: http(BUNDLER_URL)\n     * }).extend(bundlerActions)\n     *\n     * const supportedEntryPoints = await bundlerClient.supportedEntryPoints()\n     *\n     * // Return ['0x5FF137D4b0FDCD49DcA30c7CF57E578a026d2789']\n     */\n    supportedEntryPoints: () => Promise<EntryPoint[]>\n    /**\n     *\n     * Returns the supported chain id by the bundler service\n     *\n     * - Docs: https://docs.pimlico.io/permissionless/reference/bundler-actions/chainId\n     *\n     * @returns Supported chain id\n     *\n     * @example\n     * import { createClient } from \"viem\"\n     * import { bundlerActions } from \"permissionless\"\n     *\n     * const bundlerClient = createClient({\n     *      chain: goerli,\n     *      transport: http(BUNDLER_URL)\n     * }).extend(bundlerActions)\n     *\n     * const chainId = await bundlerClient.chainId()\n     * // Return 5n for Goerli\n     */\n    chainId: () => Promise<number>\n    /**\n     *\n     * Returns the user operation from userOpHash\n     *\n     * - Docs: https://docs.pimlico.io/permissionless/reference/bundler-actions/getUserOperationByHash\n     *\n     * @param args {@link GetUserOperationByHash} UserOpHash that was returned by {@link sendUserOperation}\n     * @returns userOperation along with entryPoint, transactionHash, blockHash, blockNumber if found or null\n     *\n     * @example\n     * import { createClient } from \"viem\"\n     * import { bundlerActions } from \"permissionless\"\n     *\n     * const bundlerClient = createClient({\n     *      chain: goerli,\n     *      transport: http(BUNDLER_URL)\n     * }).extend(bundlerActions)\n     *\n     * await bundlerClient.getUserOperationByHash(userOpHash)\n     *\n     */\n    getUserOperationByHash: (\n        args: Prettify<GetUserOperationByHashParameters>\n    ) => Promise<Prettify<GetUserOperationByHashReturnType<entryPoint>> | null>\n    /**\n     *\n     * Returns the user operation receipt from userOpHash\n     *\n     * - Docs: https://docs.pimlico.io/permissionless/reference/bundler-actions/getUserOperationReceipt\n     *\n     * @param args {@link GetUserOperationReceiptParameters} UserOpHash that was returned by {@link sendUserOperation}\n     * @returns user operation receipt {@link GetUserOperationReceiptReturnType} if found or null\n     *\n     * @example\n     * import { createClient } from \"viem\"\n     * import { bundlerActions } from \"permissionless\"\n     *\n     * const bundlerClient = createClient({\n     *      chain: goerli,\n     *      transport: http(BUNDLER_URL)\n     * }).extend(bundlerActions)\n     *\n     * await bundlerClient.getUserOperationReceipt({hash: userOpHash})\n     *\n     */\n    getUserOperationReceipt: (\n        args: Prettify<GetUserOperationReceiptParameters>\n    ) => Promise<Prettify<GetUserOperationReceiptReturnType> | null>\n\n    /**\n     * Waits for the User Operation to be included on a [Block](https://viem.sh/docs/glossary/terms.html#block) (one confirmation), and then returns the [User Operation Receipt](https://docs.pimlico.io/permissionless/reference/bundler-actions/getUserOperationReceipt).\n     *\n     * - Docs: https://docs.pimlico.io/permissionless/reference/bundler-actions/waitForUserOperationReceipt\n     *\n     * @param client - Bundler Client to use\n     * @param parameters - {@link WaitForUserOperationReceiptParameters}\n     * @returns The transaction receipt. {@link GetUserOperationReceiptReturnType}\n     *\n     * @example\n     * import { createBundlerClient, waitForUserOperationReceipt, http } from 'viem'\n     * import { mainnet } from 'viem/chains'\n     *\n     * const bundlerClient = createBundlerClient({\n     *   chain: mainnet,\n     *   transport: http(),\n     * })\n     * const userOperationReceipt = await bundlerClient.waitForUserOperationReceipt({\n     *   hash: '0x4ca7ee652d57678f26e887c149ab0735f41de37bcad58c9f6d3ed5824f15b74d',\n     * })\n     */\n    waitForUserOperationReceipt: (\n        args: Prettify<WaitForUserOperationReceiptParameters>\n    ) => Promise<Prettify<GetUserOperationReceiptReturnType>>\n}\n\nconst bundlerActions =\n    <entryPoint extends EntryPoint>(entryPointAddress: entryPoint) =>\n    (client: Client): BundlerActions<entryPoint> => ({\n        sendUserOperation: async (\n            args: Omit<SendUserOperationParameters<entryPoint>, \"entryPoint\">\n        ): Promise<Hash> =>\n            sendUserOperation<entryPoint>(client as BundlerClient<entryPoint>, {\n                ...args,\n                entryPoint: entryPointAddress\n            }),\n        estimateUserOperationGas: (\n            args: Omit<\n                EstimateUserOperationGasParameters<entryPoint>,\n                \"entryPoint\"\n            >,\n            stateOverrides?: StateOverrides\n        ) =>\n            estimateUserOperationGas<entryPoint>(\n                client as BundlerClient<entryPoint>,\n                { ...args, entryPoint: entryPointAddress },\n                stateOverrides\n            ),\n        supportedEntryPoints: (): Promise<EntryPoint[]> =>\n            supportedEntryPoints(client as BundlerClient<entryPoint>),\n        chainId: () => chainId(client as BundlerClient<entryPoint>),\n        getUserOperationByHash: (args: GetUserOperationByHashParameters) =>\n            getUserOperationByHash<entryPoint>(\n                client as BundlerClient<entryPoint>,\n                args\n            ),\n        getUserOperationReceipt: (args: GetUserOperationReceiptParameters) =>\n            getUserOperationReceipt(client as BundlerClient<entryPoint>, args),\n        waitForUserOperationReceipt: (\n            args: WaitForUserOperationReceiptParameters\n        ) =>\n            waitForUserOperationReceipt(\n                client as BundlerClient<entryPoint>,\n                args\n            )\n    })\n\nexport { bundlerActions }\n"],
  "mappings": "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",
  "names": ["multiplier", "requiredGas", "hashedInitCode", "hashedCallData", "hashedPaymasterAndData", "chainId", "chainId", "cause", "cause", "listeners", "cleanup"]
}

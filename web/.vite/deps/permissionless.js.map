{
  "version": 3,
  "sources": ["../../node_modules/permissionless/actions/public/getSenderAddress.ts", "../../node_modules/permissionless/actions/public/getAccountNonce.ts", "../../node_modules/permissionless/clients/createBundlerClient.ts", "../../node_modules/permissionless/actions/smartAccount/prepareUserOperationRequest.ts", "../../node_modules/permissionless/actions/smartAccount/sendUserOperation.ts", "../../node_modules/permissionless/actions/smartAccount/deployContract.ts", "../../node_modules/permissionless/actions/smartAccount/sendTransaction.ts", "../../node_modules/permissionless/actions/smartAccount/signMessage.ts", "../../node_modules/permissionless/actions/smartAccount/signTypedData.ts", "../../node_modules/permissionless/actions/smartAccount/sendTransactions.ts", "../../node_modules/permissionless/actions/smartAccount/writeContract.ts", "../../node_modules/permissionless/clients/decorators/smartAccount.ts", "../../node_modules/permissionless/clients/createSmartAccountClient.ts"],
  "sourcesContent": ["import {\n    type Address,\n    BaseError,\n    type CallExecutionErrorType,\n    type Chain,\n    type Client,\n    type ContractFunctionExecutionErrorType,\n    type ContractFunctionRevertedErrorType,\n    type Hex,\n    type RpcRequestErrorType,\n    type Transport,\n    concat,\n    decodeErrorResult\n} from \"viem\"\n\nimport { simulateContract } from \"viem/actions\"\nimport { getAction } from \"viem/utils\"\nimport type { Prettify } from \"../../types/\"\nimport type {\n    ENTRYPOINT_ADDRESS_V06_TYPE,\n    EntryPoint\n} from \"../../types/entrypoint\"\n\nexport type GetSenderAddressParams<entryPoint extends EntryPoint> =\n    entryPoint extends ENTRYPOINT_ADDRESS_V06_TYPE\n        ? {\n              initCode: Hex\n              entryPoint: entryPoint\n              factory?: never\n              factoryData?: never\n          }\n        : {\n              entryPoint: entryPoint\n              factory: Address\n              factoryData: Hex\n              initCode?: never\n          }\n\nexport class InvalidEntryPointError extends BaseError {\n    override name = \"InvalidEntryPointError\"\n\n    constructor({\n        cause,\n        entryPoint\n    }: { cause?: BaseError; entryPoint?: Address } = {}) {\n        super(\n            `The entry point address (\\`entryPoint\\`${\n                entryPoint ? ` = ${entryPoint}` : \"\"\n            }) is not a valid entry point. getSenderAddress did not revert with a SenderAddressResult error.`,\n            {\n                cause\n            }\n        )\n    }\n}\n\n/**\n * Returns the address of the account that will be deployed with the given init code.\n *\n * - Docs: https://docs.pimlico.io/permissionless/reference/public-actions/getSenderAddress\n *\n * @param client {@link Client} that you created using viem's createPublicClient.\n * @param args {@link GetSenderAddressParams} initCode & entryPoint\n * @returns Sender's Address\n *\n * @example\n * import { createPublicClient } from \"viem\"\n * import { getSenderAddress } from \"permissionless/actions\"\n *\n * const publicClient = createPublicClient({\n *      chain: goerli,\n *      transport: http(\"https://goerli.infura.io/v3/your-infura-key\")\n * })\n *\n * const senderAddress = await getSenderAddress(publicClient, {\n *      initCode,\n *      entryPoint\n * })\n *\n * // Return '0x7a88a206ba40b37a8c07a2b5688cf8b287318b63'\n */\nexport const getSenderAddress = async <\n    entryPoint extends EntryPoint,\n    TTransport extends Transport = Transport,\n    TChain extends Chain | undefined = Chain | undefined\n>(\n    client: Client<TTransport, TChain>,\n    args: Prettify<GetSenderAddressParams<entryPoint>>\n): Promise<Address> => {\n    const { initCode, entryPoint, factory, factoryData } = args\n\n    if (!initCode && !factory && !factoryData) {\n        throw new Error(\n            \"Either `initCode` or `factory` and `factoryData` must be provided\"\n        )\n    }\n\n    try {\n        await getAction(\n            client,\n            simulateContract,\n            \"simulateContract\"\n        )({\n            address: entryPoint,\n            abi: [\n                {\n                    inputs: [\n                        {\n                            internalType: \"address\",\n                            name: \"sender\",\n                            type: \"address\"\n                        }\n                    ],\n                    name: \"SenderAddressResult\",\n                    type: \"error\"\n                },\n                {\n                    inputs: [\n                        {\n                            internalType: \"bytes\",\n                            name: \"initCode\",\n                            type: \"bytes\"\n                        }\n                    ],\n                    name: \"getSenderAddress\",\n                    outputs: [],\n                    stateMutability: \"nonpayable\",\n                    type: \"function\"\n                }\n            ],\n            functionName: \"getSenderAddress\",\n            args: [initCode || concat([factory as Hex, factoryData as Hex])]\n        })\n    } catch (e) {\n        const err = e as ContractFunctionExecutionErrorType\n\n        if (err.cause.name === \"ContractFunctionRevertedError\") {\n            const revertError = err.cause as ContractFunctionRevertedErrorType\n            const errorName = revertError.data?.errorName ?? \"\"\n            if (\n                errorName === \"SenderAddressResult\" &&\n                revertError.data?.args &&\n                revertError.data?.args[0]\n            ) {\n                return revertError.data?.args[0] as Address\n            }\n        }\n\n        if (err.cause.name === \"CallExecutionError\") {\n            const callExecutionError = err.cause as CallExecutionErrorType\n            if (callExecutionError.cause.name === \"RpcRequestError\") {\n                const revertError =\n                    callExecutionError.cause as RpcRequestErrorType\n                // biome-ignore lint/suspicious/noExplicitAny: fuse issues\n                const data = (revertError as unknown as any).cause.data.split(\n                    \" \"\n                )[1]\n\n                const error = decodeErrorResult({\n                    abi: [\n                        {\n                            inputs: [\n                                {\n                                    internalType: \"address\",\n                                    name: \"sender\",\n                                    type: \"address\"\n                                }\n                            ],\n                            name: \"SenderAddressResult\",\n                            type: \"error\"\n                        }\n                    ],\n                    data\n                })\n\n                return error.args[0] as Address\n            }\n\n            if (callExecutionError.cause.name === \"InvalidInputRpcError\") {\n                //Ganache local testing returns \"InvalidInputRpcError\" with data in regular format\n                const revertError =\n                    callExecutionError.cause as RpcRequestErrorType\n                // biome-ignore lint/suspicious/noExplicitAny: fuse issues\n                const data = (revertError as unknown as any).cause.data\n\n                const error = decodeErrorResult({\n                    abi: [\n                        {\n                            inputs: [\n                                {\n                                    internalType: \"address\",\n                                    name: \"sender\",\n                                    type: \"address\"\n                                }\n                            ],\n                            name: \"SenderAddressResult\",\n                            type: \"error\"\n                        }\n                    ],\n                    data\n                })\n\n                return error.args[0] as Address\n            }\n        }\n\n        throw e\n    }\n\n    throw new InvalidEntryPointError({ entryPoint })\n}\n", "import type { Address, Chain, Client, Transport } from \"viem\"\nimport { readContract } from \"viem/actions\"\nimport { getAction } from \"viem/utils\"\nimport type { Prettify } from \"../../types/\"\nimport type { EntryPoint } from \"../../types/entrypoint\"\n\nexport type GetAccountNonceParams = {\n    sender: Address\n    entryPoint: EntryPoint\n    key?: bigint\n}\n\n/**\n * Returns the nonce of the account with the entry point.\n *\n * - Docs: https://docs.pimlico.io/permissionless/reference/public-actions/getAccountNonce\n *\n * @param client {@link client} that you created using viem's createPublicClient.\n * @param args {@link GetAccountNonceParams} address, entryPoint & key\n * @returns bigint nonce\n *\n * @example\n * import { createPublicClient } from \"viem\"\n * import { getAccountNonce } from \"permissionless/actions\"\n *\n * const client = createPublicClient({\n *      chain: goerli,\n *      transport: http(\"https://goerli.infura.io/v3/your-infura-key\")\n * })\n *\n * const nonce = await getAccountNonce(client, {\n *      address,\n *      entryPoint,\n *      key\n * })\n *\n * // Return 0n\n */\nexport const getAccountNonce = async <\n    TTransport extends Transport = Transport,\n    TChain extends Chain | undefined = Chain | undefined\n>(\n    client: Client<TTransport, TChain>,\n    args: Prettify<GetAccountNonceParams>\n): Promise<bigint> => {\n    const { sender, entryPoint, key = BigInt(0) } = args\n\n    return await getAction(\n        client,\n        readContract,\n        \"readContract\"\n    )({\n        address: entryPoint,\n        abi: [\n            {\n                inputs: [\n                    {\n                        name: \"sender\",\n                        type: \"address\"\n                    },\n                    {\n                        name: \"key\",\n                        type: \"uint192\"\n                    }\n                ],\n                name: \"getNonce\",\n                outputs: [\n                    {\n                        name: \"nonce\",\n                        type: \"uint256\"\n                    }\n                ],\n                stateMutability: \"view\",\n                type: \"function\"\n            }\n        ],\n        functionName: \"getNonce\",\n        args: [sender, key]\n    })\n}\n", "import type {\n    Account,\n    Chain,\n    Client,\n    PublicClientConfig,\n    Transport\n} from \"viem\"\nimport { createClient } from \"viem\"\nimport type { BundlerRpcSchema } from \"../types/bundler\"\nimport type { EntryPoint } from \"../types/entrypoint\"\nimport { type BundlerActions, bundlerActions } from \"./decorators/bundler\"\n\nexport type BundlerClient<\n    entryPoint extends EntryPoint,\n    TChain extends Chain | undefined = Chain | undefined\n> = Client<\n    Transport,\n    TChain,\n    Account | undefined,\n    BundlerRpcSchema<entryPoint>,\n    BundlerActions<entryPoint>\n>\n/**\n * Creates a EIP-4337 compliant Bundler Client with a given [Transport](https://viem.sh/docs/clients/intro.html) configured for a [Chain](https://viem.sh/docs/clients/chains.html).\n *\n * - Docs: https://docs.pimlico.io/permissionless/reference/clients/bundlerClient\n *\n * A Bundler Client is an interface to \"erc 4337\" [JSON-RPC API](https://eips.ethereum.org/EIPS/eip-4337#rpc-methods-eth-namespace) methods such as sending user operation, estimating gas for a user operation, get user operation receipt, etc through Bundler Actions.\n *\n * @param config - {@link PublicClientConfig}\n * @returns A Bundler Client. {@link BundlerClient}\n *\n * @example\n * import { createPublicClient, http } from 'viem'\n * import { mainnet } from 'viem/chains'\n *\n * const bundlerClient = createBundlerClient({\n *   chain: mainnet,\n *   transport: http(BUNDLER_URL),\n * })\n */\nexport const createBundlerClient = <\n    entryPoint extends EntryPoint,\n    transport extends Transport = Transport,\n    chain extends Chain | undefined = undefined\n>(\n    parameters: PublicClientConfig<transport, chain> & {\n        entryPoint: entryPoint\n    }\n): BundlerClient<entryPoint> => {\n    const { key = \"public\", name = \"Bundler Client\" } = parameters\n    const client = createClient({\n        ...parameters,\n        key,\n        name,\n        type: \"bundlerClient\"\n    })\n    return client.extend(bundlerActions(parameters.entryPoint))\n}\n", "import type { Chain, Client, Transport } from \"viem\"\nimport { estimateFeesPerGas } from \"viem/actions\"\nimport { getAction } from \"viem/utils\"\nimport type { SmartAccount } from \"../../accounts/types\"\nimport type { PartialPick } from \"../../types\"\nimport type {\n    GetAccountParameter,\n    PartialBy,\n    Prettify,\n    UserOperation\n} from \"../../types/\"\nimport type { StateOverrides } from \"../../types/bundler\"\nimport type {\n    ENTRYPOINT_ADDRESS_V06_TYPE,\n    ENTRYPOINT_ADDRESS_V07_TYPE,\n    EntryPoint,\n    GetEntryPointVersion\n} from \"../../types/entrypoint\"\nimport { AccountOrClientNotFoundError, parseAccount } from \"../../utils/\"\nimport { getEntryPointVersion } from \"../../utils/getEntryPointVersion\"\nimport { estimateUserOperationGas } from \"../bundler/estimateUserOperationGas\"\n\nexport type SponsorUserOperationReturnType<entryPoint extends EntryPoint> =\n    entryPoint extends ENTRYPOINT_ADDRESS_V06_TYPE\n        ? Prettify<\n              Pick<\n                  UserOperation<\"v0.6\">,\n                  | \"callGasLimit\"\n                  | \"verificationGasLimit\"\n                  | \"preVerificationGas\"\n                  | \"paymasterAndData\"\n              > &\n                  PartialPick<\n                      UserOperation<\"v0.6\">,\n                      \"maxFeePerGas\" | \"maxPriorityFeePerGas\"\n                  >\n          >\n        : Prettify<\n              Pick<\n                  UserOperation<\"v0.7\">,\n                  | \"callGasLimit\"\n                  | \"verificationGasLimit\"\n                  | \"preVerificationGas\"\n                  | \"paymaster\"\n                  | \"paymasterVerificationGasLimit\"\n                  | \"paymasterPostOpGasLimit\"\n                  | \"paymasterData\"\n              > &\n                  PartialPick<\n                      UserOperation<\"v0.7\">,\n                      \"maxFeePerGas\" | \"maxPriorityFeePerGas\"\n                  >\n          >\n\nexport type Middleware<entryPoint extends EntryPoint> = {\n    middleware?:\n        | ((args: {\n              userOperation: UserOperation<GetEntryPointVersion<entryPoint>>\n              entryPoint: entryPoint\n          }) => Promise<UserOperation<GetEntryPointVersion<entryPoint>>>)\n        | {\n              gasPrice?: () => Promise<{\n                  maxFeePerGas: bigint\n                  maxPriorityFeePerGas: bigint\n              }>\n              sponsorUserOperation?: (args: {\n                  userOperation: UserOperation<GetEntryPointVersion<entryPoint>>\n                  entryPoint: entryPoint\n              }) => Promise<SponsorUserOperationReturnType<entryPoint>>\n          }\n}\n\nexport type PrepareUserOperationRequestParameters<\n    entryPoint extends EntryPoint,\n    TAccount extends SmartAccount<entryPoint> | undefined =\n        | SmartAccount<entryPoint>\n        | undefined\n> = {\n    userOperation: entryPoint extends ENTRYPOINT_ADDRESS_V06_TYPE\n        ? PartialBy<\n              UserOperation<\"v0.6\">,\n              | \"sender\"\n              | \"nonce\"\n              | \"initCode\"\n              | \"callGasLimit\"\n              | \"verificationGasLimit\"\n              | \"preVerificationGas\"\n              | \"maxFeePerGas\"\n              | \"maxPriorityFeePerGas\"\n              | \"paymasterAndData\"\n              | \"signature\"\n          >\n        : PartialBy<\n              UserOperation<\"v0.7\">,\n              | \"sender\"\n              | \"nonce\"\n              | \"factory\"\n              | \"factoryData\"\n              | \"callGasLimit\"\n              | \"verificationGasLimit\"\n              | \"preVerificationGas\"\n              | \"maxFeePerGas\"\n              | \"maxPriorityFeePerGas\"\n              | \"paymaster\"\n              | \"paymasterVerificationGasLimit\"\n              | \"paymasterPostOpGasLimit\"\n              | \"paymasterData\"\n              | \"signature\"\n          >\n} & GetAccountParameter<entryPoint, TAccount> &\n    Middleware<entryPoint>\n\nexport type PrepareUserOperationRequestReturnType<\n    entryPoint extends EntryPoint\n> = UserOperation<GetEntryPointVersion<entryPoint>>\n\nasync function prepareUserOperationRequestForEntryPointV06<\n    entryPoint extends EntryPoint = ENTRYPOINT_ADDRESS_V06_TYPE,\n    TTransport extends Transport = Transport,\n    TChain extends Chain | undefined = Chain | undefined,\n    TAccount extends SmartAccount<entryPoint> | undefined =\n        | SmartAccount<entryPoint>\n        | undefined\n>(\n    client: Client<TTransport, TChain, TAccount>,\n    args: Prettify<PrepareUserOperationRequestParameters<entryPoint, TAccount>>,\n    stateOverrides?: StateOverrides\n): Promise<Prettify<PrepareUserOperationRequestReturnType<entryPoint>>> {\n    const {\n        account: account_ = client.account,\n        userOperation: partialUserOperation,\n        middleware\n    } = args\n    if (!account_) throw new AccountOrClientNotFoundError()\n\n    const account = parseAccount(\n        account_\n    ) as SmartAccount<ENTRYPOINT_ADDRESS_V06_TYPE>\n\n    const [sender, nonce, initCode, callData] = await Promise.all([\n        partialUserOperation.sender || account.address,\n        partialUserOperation.nonce || account.getNonce(),\n        partialUserOperation.initCode || account.getInitCode(),\n        partialUserOperation.callData\n    ])\n\n    const userOperation: UserOperation<\"v0.6\"> = {\n        sender,\n        nonce,\n        initCode,\n        callData,\n        paymasterAndData: \"0x\",\n        signature: partialUserOperation.signature || \"0x\",\n        maxFeePerGas: partialUserOperation.maxFeePerGas || BigInt(0),\n        maxPriorityFeePerGas:\n            partialUserOperation.maxPriorityFeePerGas || BigInt(0),\n        callGasLimit: partialUserOperation.callGasLimit || BigInt(0),\n        verificationGasLimit:\n            partialUserOperation.verificationGasLimit || BigInt(0),\n        preVerificationGas: partialUserOperation.preVerificationGas || BigInt(0)\n    }\n\n    if (userOperation.signature === \"0x\") {\n        userOperation.signature = await account.getDummySignature(userOperation)\n    }\n\n    if (typeof middleware === \"function\") {\n        return middleware({\n            userOperation,\n            entryPoint: account.entryPoint\n        } as {\n            userOperation: UserOperation<GetEntryPointVersion<entryPoint>>\n            entryPoint: entryPoint\n        }) as Promise<PrepareUserOperationRequestReturnType<entryPoint>>\n    }\n\n    if (middleware && typeof middleware !== \"function\" && middleware.gasPrice) {\n        const gasPrice = await middleware.gasPrice()\n        userOperation.maxFeePerGas = gasPrice.maxFeePerGas\n        userOperation.maxPriorityFeePerGas = gasPrice.maxPriorityFeePerGas\n    }\n\n    if (!userOperation.maxFeePerGas || !userOperation.maxPriorityFeePerGas) {\n        const estimateGas = await estimateFeesPerGas(account.client)\n        userOperation.maxFeePerGas =\n            userOperation.maxFeePerGas || estimateGas.maxFeePerGas\n        userOperation.maxPriorityFeePerGas =\n            userOperation.maxPriorityFeePerGas ||\n            estimateGas.maxPriorityFeePerGas\n    }\n\n    if (\n        middleware &&\n        typeof middleware !== \"function\" &&\n        middleware.sponsorUserOperation\n    ) {\n        const sponsorUserOperationData = (await middleware.sponsorUserOperation(\n            {\n                userOperation,\n                entryPoint: account.entryPoint\n            } as {\n                userOperation: UserOperation<GetEntryPointVersion<entryPoint>>\n                entryPoint: entryPoint\n            }\n        )) as SponsorUserOperationReturnType<ENTRYPOINT_ADDRESS_V06_TYPE>\n\n        userOperation.callGasLimit = sponsorUserOperationData.callGasLimit\n        userOperation.verificationGasLimit =\n            sponsorUserOperationData.verificationGasLimit\n        userOperation.preVerificationGas =\n            sponsorUserOperationData.preVerificationGas\n        userOperation.paymasterAndData =\n            sponsorUserOperationData.paymasterAndData\n        userOperation.maxFeePerGas =\n            sponsorUserOperationData.maxFeePerGas || userOperation.maxFeePerGas\n        userOperation.maxPriorityFeePerGas =\n            sponsorUserOperationData.maxPriorityFeePerGas ||\n            userOperation.maxPriorityFeePerGas\n        return userOperation as PrepareUserOperationRequestReturnType<entryPoint>\n    }\n\n    if (\n        !userOperation.callGasLimit ||\n        !userOperation.verificationGasLimit ||\n        !userOperation.preVerificationGas\n    ) {\n        const gasParameters = await getAction(\n            client,\n            estimateUserOperationGas,\n            \"estimateUserOperationGas\"\n        )(\n            {\n                userOperation,\n                entryPoint: account.entryPoint\n            } as {\n                userOperation: UserOperation<GetEntryPointVersion<entryPoint>>\n                entryPoint: entryPoint\n            },\n            // @ts-ignore getAction takes only two params but when compiled this will work\n            stateOverrides\n        )\n\n        userOperation.callGasLimit |= gasParameters.callGasLimit\n        userOperation.verificationGasLimit =\n            userOperation.verificationGasLimit ||\n            gasParameters.verificationGasLimit\n        userOperation.preVerificationGas =\n            userOperation.preVerificationGas || gasParameters.preVerificationGas\n    }\n\n    return userOperation as PrepareUserOperationRequestReturnType<entryPoint>\n}\n\nasync function prepareUserOperationRequestEntryPointV07<\n    entryPoint extends EntryPoint = ENTRYPOINT_ADDRESS_V07_TYPE,\n    TTransport extends Transport = Transport,\n    TChain extends Chain | undefined = Chain | undefined,\n    TAccount extends SmartAccount<entryPoint> | undefined =\n        | SmartAccount<entryPoint>\n        | undefined\n>(\n    client: Client<TTransport, TChain, TAccount>,\n    args: Prettify<PrepareUserOperationRequestParameters<entryPoint, TAccount>>,\n    stateOverrides?: StateOverrides\n): Promise<Prettify<PrepareUserOperationRequestReturnType<entryPoint>>> {\n    const {\n        account: account_ = client.account,\n        userOperation: partialUserOperation,\n        middleware\n    } = args\n    if (!account_) throw new AccountOrClientNotFoundError()\n\n    const account = parseAccount(\n        account_\n    ) as SmartAccount<ENTRYPOINT_ADDRESS_V07_TYPE>\n\n    const [sender, nonce, factory, factoryData, callData, gasEstimation] =\n        await Promise.all([\n            partialUserOperation.sender || account.address,\n            partialUserOperation.nonce || account.getNonce(),\n            partialUserOperation.factory || account.getFactory(),\n            partialUserOperation.factoryData || account.getFactoryData(),\n            partialUserOperation.callData,\n            !partialUserOperation.maxFeePerGas ||\n            !partialUserOperation.maxPriorityFeePerGas\n                ? estimateFeesPerGas(account.client)\n                : undefined\n        ])\n\n    const userOperation: UserOperation<\"v0.7\"> = {\n        sender,\n        nonce,\n        factory: factory,\n        factoryData: factoryData,\n        callData,\n        callGasLimit: partialUserOperation.callGasLimit || BigInt(0),\n        verificationGasLimit:\n            partialUserOperation.verificationGasLimit || BigInt(0),\n        preVerificationGas:\n            partialUserOperation.preVerificationGas || BigInt(0),\n        maxFeePerGas:\n            partialUserOperation.maxFeePerGas ||\n            gasEstimation?.maxFeePerGas ||\n            BigInt(0),\n        maxPriorityFeePerGas:\n            partialUserOperation.maxPriorityFeePerGas ||\n            gasEstimation?.maxPriorityFeePerGas ||\n            BigInt(0),\n        signature: partialUserOperation.signature || \"0x\"\n    }\n\n    if (userOperation.signature === \"0x\") {\n        userOperation.signature = await account.getDummySignature(userOperation)\n    }\n\n    if (typeof middleware === \"function\") {\n        return middleware({\n            userOperation,\n            entryPoint: account.entryPoint\n        } as {\n            userOperation: UserOperation<GetEntryPointVersion<entryPoint>>\n            entryPoint: entryPoint\n        }) as Promise<PrepareUserOperationRequestReturnType<entryPoint>>\n    }\n\n    if (middleware && typeof middleware !== \"function\" && middleware.gasPrice) {\n        const gasPrice = await middleware.gasPrice()\n        userOperation.maxFeePerGas = gasPrice.maxFeePerGas\n        userOperation.maxPriorityFeePerGas = gasPrice.maxPriorityFeePerGas\n    }\n\n    if (!userOperation.maxFeePerGas || !userOperation.maxPriorityFeePerGas) {\n        const estimateGas = await estimateFeesPerGas(account.client)\n        userOperation.maxFeePerGas =\n            userOperation.maxFeePerGas || estimateGas.maxFeePerGas\n        userOperation.maxPriorityFeePerGas =\n            userOperation.maxPriorityFeePerGas ||\n            estimateGas.maxPriorityFeePerGas\n    }\n\n    if (\n        middleware &&\n        typeof middleware !== \"function\" &&\n        middleware.sponsorUserOperation\n    ) {\n        const sponsorUserOperationData = (await middleware.sponsorUserOperation(\n            {\n                userOperation,\n                entryPoint: account.entryPoint\n            } as {\n                userOperation: UserOperation<GetEntryPointVersion<entryPoint>>\n                entryPoint: entryPoint\n            }\n        )) as SponsorUserOperationReturnType<ENTRYPOINT_ADDRESS_V07_TYPE>\n\n        userOperation.callGasLimit = sponsorUserOperationData.callGasLimit\n        userOperation.verificationGasLimit =\n            sponsorUserOperationData.verificationGasLimit\n        userOperation.preVerificationGas =\n            sponsorUserOperationData.preVerificationGas\n        userOperation.paymaster = sponsorUserOperationData.paymaster\n        userOperation.paymasterVerificationGasLimit =\n            sponsorUserOperationData.paymasterVerificationGasLimit\n        userOperation.paymasterPostOpGasLimit =\n            sponsorUserOperationData.paymasterPostOpGasLimit\n        userOperation.paymasterData = sponsorUserOperationData.paymasterData\n        userOperation.maxFeePerGas =\n            sponsorUserOperationData.maxFeePerGas || userOperation.maxFeePerGas\n        userOperation.maxPriorityFeePerGas =\n            sponsorUserOperationData.maxPriorityFeePerGas ||\n            userOperation.maxPriorityFeePerGas\n\n        return userOperation as PrepareUserOperationRequestReturnType<entryPoint>\n    }\n\n    if (\n        !userOperation.callGasLimit ||\n        !userOperation.verificationGasLimit ||\n        !userOperation.preVerificationGas\n    ) {\n        const gasParameters = await getAction(\n            client,\n            estimateUserOperationGas<ENTRYPOINT_ADDRESS_V07_TYPE>,\n            \"estimateUserOperationGas\"\n        )(\n            {\n                userOperation,\n                entryPoint: account.entryPoint\n            },\n            // @ts-ignore getAction takes only two params but when compiled this will work\n            stateOverrides\n        )\n\n        userOperation.callGasLimit |= gasParameters.callGasLimit\n        userOperation.verificationGasLimit =\n            userOperation.verificationGasLimit ||\n            gasParameters.verificationGasLimit\n        userOperation.preVerificationGas =\n            userOperation.preVerificationGas || gasParameters.preVerificationGas\n\n        userOperation.paymasterPostOpGasLimit =\n            userOperation.paymasterPostOpGasLimit ||\n            gasParameters.paymasterPostOpGasLimit\n        userOperation.paymasterPostOpGasLimit =\n            userOperation.paymasterPostOpGasLimit ||\n            gasParameters.paymasterPostOpGasLimit\n    }\n\n    return userOperation as PrepareUserOperationRequestReturnType<entryPoint>\n}\n\nexport async function prepareUserOperationRequest<\n    entryPoint extends EntryPoint,\n    TTransport extends Transport = Transport,\n    TChain extends Chain | undefined = Chain | undefined,\n    TAccount extends SmartAccount<entryPoint> | undefined =\n        | SmartAccount<entryPoint>\n        | undefined\n>(\n    client: Client<TTransport, TChain, TAccount>,\n    args: Prettify<PrepareUserOperationRequestParameters<entryPoint, TAccount>>,\n    stateOverrides?: StateOverrides\n): Promise<Prettify<PrepareUserOperationRequestReturnType<entryPoint>>> {\n    const { account: account_ = client.account } = args\n    if (!account_) throw new AccountOrClientNotFoundError()\n\n    const account = parseAccount(account_) as SmartAccount<entryPoint>\n\n    const entryPointVersion = getEntryPointVersion(account.entryPoint)\n\n    if (entryPointVersion === \"v0.6\") {\n        return prepareUserOperationRequestForEntryPointV06(\n            client,\n            args,\n            stateOverrides\n        ) as Promise<PrepareUserOperationRequestReturnType<entryPoint>>\n    }\n\n    return prepareUserOperationRequestEntryPointV07(\n        client,\n        args,\n        stateOverrides\n    ) as Promise<PrepareUserOperationRequestReturnType<entryPoint>>\n}\n", "import type { Chain, Client, Hash, Transport } from \"viem\"\nimport { getAction } from \"viem/utils\"\nimport type { SmartAccount } from \"../../accounts/types\"\nimport type {\n    GetAccountParameter,\n    PartialBy,\n    Prettify,\n    UserOperation\n} from \"../../types/\"\nimport type {\n    ENTRYPOINT_ADDRESS_V06_TYPE,\n    EntryPoint,\n    GetEntryPointVersion\n} from \"../../types/entrypoint\"\nimport { AccountOrClientNotFoundError, parseAccount } from \"../../utils/\"\nimport { sendUserOperation as sendUserOperationBundler } from \"../bundler/sendUserOperation\"\nimport {\n    type Middleware,\n    prepareUserOperationRequest\n} from \"./prepareUserOperationRequest\"\n\nexport type SendUserOperationParameters<\n    entryPoint extends EntryPoint,\n    TAccount extends SmartAccount<entryPoint> | undefined =\n        | SmartAccount<entryPoint>\n        | undefined\n> = {\n    userOperation: entryPoint extends ENTRYPOINT_ADDRESS_V06_TYPE\n        ? PartialBy<\n              UserOperation<\"v0.6\">,\n              | \"sender\"\n              | \"nonce\"\n              | \"initCode\"\n              | \"callGasLimit\"\n              | \"verificationGasLimit\"\n              | \"preVerificationGas\"\n              | \"maxFeePerGas\"\n              | \"maxPriorityFeePerGas\"\n              | \"paymasterAndData\"\n              | \"signature\"\n          >\n        : PartialBy<\n              UserOperation<\"v0.7\">,\n              | \"sender\"\n              | \"nonce\"\n              | \"factory\"\n              | \"factoryData\"\n              | \"callGasLimit\"\n              | \"verificationGasLimit\"\n              | \"preVerificationGas\"\n              | \"maxFeePerGas\"\n              | \"maxPriorityFeePerGas\"\n              | \"paymaster\"\n              | \"paymasterVerificationGasLimit\"\n              | \"paymasterPostOpGasLimit\"\n              | \"paymasterData\"\n              | \"signature\"\n          >\n} & GetAccountParameter<entryPoint, TAccount> &\n    Middleware<entryPoint>\n\nexport async function sendUserOperation<\n    entryPoint extends EntryPoint,\n    TTransport extends Transport = Transport,\n    TChain extends Chain | undefined = Chain | undefined,\n    TAccount extends SmartAccount<entryPoint> | undefined =\n        | SmartAccount<entryPoint>\n        | undefined\n>(\n    client: Client<TTransport, TChain, TAccount>,\n    args: Prettify<SendUserOperationParameters<entryPoint, TAccount>>\n): Promise<Hash> {\n    const { account: account_ = client.account } = args\n    if (!account_) throw new AccountOrClientNotFoundError()\n\n    const account = parseAccount(account_) as SmartAccount<entryPoint>\n\n    const userOperation = await getAction(\n        client,\n        prepareUserOperationRequest<entryPoint, TTransport, TChain, TAccount>,\n        \"prepareUserOperationRequest\"\n    )(args)\n\n    userOperation.signature = await account.signUserOperation(\n        userOperation as UserOperation<GetEntryPointVersion<entryPoint>>\n    )\n\n    return sendUserOperationBundler(client, {\n        userOperation: userOperation as UserOperation<\n            GetEntryPointVersion<entryPoint>\n        >,\n        entryPoint: account.entryPoint\n    })\n}\n", "import type {\n    Abi,\n    Chain,\n    Client,\n    DeployContractParameters,\n    EncodeDeployDataParameters,\n    Hash,\n    Transport\n} from \"viem\"\nimport { getAction } from \"viem/utils\"\nimport type { SmartAccount } from \"../../accounts/types\"\nimport type { Prettify } from \"../../types/\"\nimport type { EntryPoint } from \"../../types/entrypoint\"\nimport { parseAccount } from \"../../utils/\"\nimport { AccountOrClientNotFoundError } from \"../../utils/signUserOperationHashWithECDSA\"\nimport { waitForUserOperationReceipt } from \"../bundler/waitForUserOperationReceipt\"\nimport { type Middleware } from \"./prepareUserOperationRequest\"\nimport { sendUserOperation } from \"./sendUserOperation\"\n\nexport type DeployContractParametersWithPaymaster<\n    entryPoint extends EntryPoint,\n    TAbi extends Abi | readonly unknown[] = Abi | readonly unknown[],\n    TChain extends Chain | undefined = Chain | undefined,\n    TAccount extends SmartAccount<entryPoint> | undefined =\n        | SmartAccount<entryPoint>\n        | undefined,\n    TChainOverride extends Chain | undefined = Chain | undefined\n> = DeployContractParameters<TAbi, TChain, TAccount, TChainOverride> &\n    Middleware<entryPoint>\n\n/**\n * Deploys a contract to the network, given bytecode and constructor arguments.\n * This function also allows you to sponsor this transaction if sender is a smartAccount\n *\n * - Docs: https://viem.sh/docs/contract/deployContract.html\n * - Examples: https://stackblitz.com/github/wagmi-dev/viem/tree/main/examples/contracts/deploying-contracts\n *\n * @param client - Client to use\n * @param parameters - {@link DeployContractParameters}\n * @returns The [Transaction](https://viem.sh/docs/glossary/terms.html#transaction) hash.\n *\n * @example\n * import { createWalletClient, http } from 'viem'\n * import { privateKeyToAccount } from 'viem/accounts'\n * import { mainnet } from 'viem/chains'\n * import { deployContract } from 'viem/contract'\n *\n * const client = createWalletClient({\n *   account: privateKeyToAccount('0x…'),\n *   chain: mainnet,\n *   transport: http(),\n * })\n * const hash = await deployContract(client, {\n *   abi: [],\n *   account: '0x…,\n *   bytecode: '0x608060405260405161083e38038061083e833981016040819052610...',\n * })\n */\nexport async function deployContract<\n    entryPoint extends EntryPoint,\n    TChain extends Chain | undefined,\n    TAccount extends SmartAccount<entryPoint> | undefined\n>(\n    client: Client<Transport, TChain, TAccount>,\n    args: Prettify<DeployContractParametersWithPaymaster<entryPoint>>\n): Promise<Hash> {\n    const {\n        abi,\n        args: constructorArgs,\n        bytecode,\n        middleware,\n        ...request\n    } = args\n\n    const { account: account_ = client.account } = request\n\n    if (!account_) {\n        throw new AccountOrClientNotFoundError({\n            docsPath: \"/docs/actions/wallet/sendTransaction\"\n        })\n    }\n\n    const account = parseAccount(account_) as SmartAccount<entryPoint>\n\n    const userOpHash = await getAction(\n        client,\n        sendUserOperation<entryPoint>,\n        \"sendUserOperation\"\n    )({\n        userOperation: {\n            sender: account.address,\n            maxFeePerGas: request.maxFeePerGas || BigInt(0),\n            maxPriorityFeePerGas: request.maxPriorityFeePerGas || BigInt(0),\n            callData: await account.encodeDeployCallData({\n                abi,\n                bytecode,\n                args: constructorArgs\n            } as EncodeDeployDataParameters)\n        },\n        account: account,\n        middleware\n    })\n\n    const userOperationReceipt = await getAction(\n        client,\n        waitForUserOperationReceipt,\n        \"waitForUserOperationReceipt\"\n    )({\n        hash: userOpHash\n    })\n\n    return userOperationReceipt?.receipt.transactionHash\n}\n", "import type {\n    Chain,\n    Client,\n    Hash,\n    SendTransactionParameters,\n    Transport\n} from \"viem\"\nimport { getAction } from \"viem/utils\"\nimport { type SmartAccount } from \"../../accounts/types\"\nimport type { Prettify } from \"../../types/\"\nimport type { EntryPoint } from \"../../types/entrypoint\"\nimport { AccountOrClientNotFoundError, parseAccount } from \"../../utils/\"\nimport { waitForUserOperationReceipt } from \"../bundler/waitForUserOperationReceipt\"\nimport { type Middleware } from \"./prepareUserOperationRequest\"\nimport { sendUserOperation } from \"./sendUserOperation\"\n\nexport type SendTransactionWithPaymasterParameters<\n    entryPoint extends EntryPoint,\n    TChain extends Chain | undefined = Chain | undefined,\n    TAccount extends SmartAccount<entryPoint> | undefined =\n        | SmartAccount<entryPoint>\n        | undefined,\n    TChainOverride extends Chain | undefined = Chain | undefined\n> = SendTransactionParameters<TChain, TAccount, TChainOverride> &\n    Middleware<entryPoint>\n\n/**\n * Creates, signs, and sends a new transaction to the network.\n * This function also allows you to sponsor this transaction if sender is a smartAccount\n *\n * - Docs: https://viem.sh/docs/actions/wallet/sendTransaction.html\n * - Examples: https://stackblitz.com/github/wagmi-dev/viem/tree/main/examples/transactions/sending-transactions\n * - JSON-RPC Methods:\n *   - JSON-RPC Accounts: [`eth_sendTransaction`](https://ethereum.org/en/developers/docs/apis/json-rpc/#eth_sendtransaction)\n *   - Local Accounts: [`eth_sendRawTransaction`](https://ethereum.org/en/developers/docs/apis/json-rpc/#eth_sendrawtransaction)\n *\n * @param client - Client to use\n * @param parameters - {@link SendTransactionParameters}\n * @returns The [Transaction](https://viem.sh/docs/glossary/terms.html#transaction) hash.\n *\n * @example\n * import { createWalletClient, custom } from 'viem'\n * import { mainnet } from 'viem/chains'\n * import { sendTransaction } from 'viem/wallet'\n *\n * const client = createWalletClient({\n *   chain: mainnet,\n *   transport: custom(window.ethereum),\n * })\n * const hash = await sendTransaction(client, {\n *   account: '0xA0Cf798816D4b9b9866b5330EEa46a18382f251e',\n *   to: '0x70997970c51812dc3a010c7d01b50e0d17dc79c8',\n *   value: 1000000000000000000n,\n * })\n *\n * @example\n * // Account Hoisting\n * import { createWalletClient, http } from 'viem'\n * import { privateKeyToAccount } from 'viem/accounts'\n * import { mainnet } from 'viem/chains'\n * import { sendTransaction } from 'viem/wallet'\n *\n * const client = createWalletClient({\n *   account: privateKeyToAccount('0x…'),\n *   chain: mainnet,\n *   transport: http(),\n * })\n * const hash = await sendTransaction(client, {\n *   to: '0x70997970c51812dc3a010c7d01b50e0d17dc79c8',\n *   value: 1000000000000000000n,\n * })\n */\nexport async function sendTransaction<\n    TChain extends Chain | undefined,\n    TAccount extends SmartAccount<entryPoint> | undefined,\n    entryPoint extends EntryPoint,\n    TChainOverride extends Chain | undefined = Chain | undefined\n>(\n    client: Client<Transport, TChain, TAccount>,\n    args: Prettify<\n        SendTransactionWithPaymasterParameters<\n            entryPoint,\n            TChain,\n            TAccount,\n            TChainOverride\n        >\n    >\n): Promise<Hash> {\n    const {\n        account: account_ = client.account,\n        data,\n        maxFeePerGas,\n        maxPriorityFeePerGas,\n        to,\n        value,\n        nonce,\n        middleware\n    } = args\n\n    if (!account_) {\n        throw new AccountOrClientNotFoundError({\n            docsPath: \"/docs/actions/wallet/sendTransaction\"\n        })\n    }\n\n    const account = parseAccount(account_) as SmartAccount<entryPoint>\n\n    if (!to) throw new Error(\"Missing to address\")\n\n    if (account.type !== \"local\") {\n        throw new Error(\"RPC account type not supported\")\n    }\n\n    const callData = await account.encodeCallData({\n        to,\n        value: value || BigInt(0),\n        data: data || \"0x\"\n    })\n\n    const userOpHash = await getAction(\n        client,\n        sendUserOperation<entryPoint>,\n        \"sendUserOperation\"\n    )({\n        userOperation: {\n            sender: account.address,\n            maxFeePerGas: maxFeePerGas || BigInt(0),\n            maxPriorityFeePerGas: maxPriorityFeePerGas || BigInt(0),\n            callData: callData,\n            nonce: nonce ? BigInt(nonce) : undefined\n        },\n        account: account,\n        middleware\n    })\n\n    const userOperationReceipt = await getAction(\n        client,\n        waitForUserOperationReceipt,\n        \"waitForUserOperationReceipt\"\n    )({\n        hash: userOpHash\n    })\n\n    return userOperationReceipt?.receipt.transactionHash\n}\n", "import type {\n    Chain,\n    Client,\n    SignMessageParameters,\n    SignMessageReturnType,\n    Transport\n} from \"viem\"\nimport { type SmartAccount } from \"../../accounts/types\"\nimport type { EntryPoint } from \"../../types/entrypoint\"\nimport { AccountOrClientNotFoundError, parseAccount } from \"../../utils/\"\n\n/**\n * Calculates an Ethereum-specific signature in [EIP-191 format](https://eips.ethereum.org/EIPS/eip-191): `keccak256(\"\\x19Ethereum Signed Message:\\n\" + len(message) + message))`.\n *\n * - Docs: https://viem.sh/docs/actions/wallet/signMessage.html\n * - JSON-RPC Methods:\n *   - JSON-RPC Accounts: [`personal_sign`](https://docs.metamask.io/guide/signing-data.html#personal-sign)\n *   - Local Accounts: Signs locally. No JSON-RPC request.\n *\n * With the calculated signature, you can:\n * - use [`verifyMessage`](https://viem.sh/docs/utilities/verifyMessage.html) to verify the signature,\n * - use [`recoverMessageAddress`](https://viem.sh/docs/utilities/recoverMessageAddress.html) to recover the signing address from a signature.\n *\n * @param client - Client to use\n * @param parameters - {@link SignMessageParameters}\n * @returns The signed message. {@link SignMessageReturnType}\n *\n * @example\n * import { createWalletClient, custom } from 'viem'\n * import { mainnet } from 'viem/chains'\n * import { signMessage } from 'viem/wallet'\n *\n * const client = createWalletClient({\n *   chain: mainnet,\n *   transport: custom(window.ethereum),\n * })\n * const signature = await signMessage(client, {\n *   account: '0xA0Cf798816D4b9b9866b5330EEa46a18382f251e',\n *   message: 'hello world',\n * })\n *\n * @example\n * // Account Hoisting\n * import { createWalletClient, custom } from 'viem'\n * import { privateKeyToAccount } from 'viem/accounts'\n * import { mainnet } from 'viem/chains'\n * import { signMessage } from 'viem/wallet'\n *\n * const client = createWalletClient({\n *   account: privateKeyToAccount('0x…'),\n *   chain: mainnet,\n *   transport: custom(window.ethereum),\n * })\n * const signature = await signMessage(client, {\n *   message: 'hello world',\n * })\n */\nexport async function signMessage<\n    entryPoint extends EntryPoint,\n    TChain extends Chain | undefined,\n    TAccount extends SmartAccount<entryPoint> | undefined\n>(\n    client: Client<Transport, TChain, TAccount>,\n    {\n        account: account_ = client.account,\n        message\n    }: SignMessageParameters<TAccount>\n): Promise<SignMessageReturnType> {\n    if (!account_)\n        throw new AccountOrClientNotFoundError({\n            docsPath: \"/docs/actions/wallet/signMessage\"\n        })\n\n    const account = parseAccount(account_)\n    if (account.type === \"local\") return account.signMessage({ message })\n\n    throw new Error(\"Sign message is not supported by this account\")\n}\n", "import {\n    type Chain,\n    type Client,\n    type SignTypedDataParameters,\n    type SignTypedDataReturnType,\n    type Transport,\n    type TypedData,\n    type TypedDataDefinition,\n    getTypesForEIP712Domain,\n    validateTypedData\n} from \"viem\"\nimport type { SmartAccount } from \"../../accounts/types\"\nimport type { EntryPoint } from \"../../types/entrypoint\"\nimport { AccountOrClientNotFoundError, parseAccount } from \"../../utils/\"\n\n/**\n * Signs typed data and calculates an Ethereum-specific signature in [https://eips.ethereum.org/EIPS/eip-712](https://eips.ethereum.org/EIPS/eip-712): `sign(keccak256(\"\\x19\\x01\" ‖ domainSeparator ‖ hashStruct(message)))`\n *\n * - Docs: https://viem.sh/docs/actions/wallet/signTypedData.html\n * - JSON-RPC Methods:\n *   - JSON-RPC Accounts: [`eth_signTypedData_v4`](https://docs.metamask.io/guide/signing-data.html#signtypeddata-v4)\n *   - Local Accounts: Signs locally. No JSON-RPC request.\n *\n * @param client - Client to use\n * @param parameters - {@link SignTypedDataParameters}\n * @returns The signed data. {@link SignTypedDataReturnType}\n *\n * @example\n * import { createWalletClient, custom } from 'viem'\n * import { mainnet } from 'viem/chains'\n * import { signTypedData } from 'viem/wallet'\n *\n * const client = createWalletClient({\n *   chain: mainnet,\n *   transport: custom(window.ethereum),\n * })\n * const signature = await signTypedData(client, {\n *   account: '0xA0Cf798816D4b9b9866b5330EEa46a18382f251e',\n *   domain: {\n *     name: 'Ether Mail',\n *     version: '1',\n *     chainId: 1,\n *     verifyingContract: '0xCcCCccccCCCCcCCCCCCcCcCccCcCCCcCcccccccC',\n *   },\n *   types: {\n *     Person: [\n *       { name: 'name', type: 'string' },\n *       { name: 'wallet', type: 'address' },\n *     ],\n *     Mail: [\n *       { name: 'from', type: 'Person' },\n *       { name: 'to', type: 'Person' },\n *       { name: 'contents', type: 'string' },\n *     ],\n *   },\n *   primaryType: 'Mail',\n *   message: {\n *     from: {\n *       name: 'Cow',\n *       wallet: '0xCD2a3d9F938E13CD947Ec05AbC7FE734Df8DD826',\n *     },\n *     to: {\n *       name: 'Bob',\n *       wallet: '0xbBbBBBBbbBBBbbbBbbBbbbbBBbBbbbbBbBbbBBbB',\n *     },\n *     contents: 'Hello, Bob!',\n *   },\n * })\n *\n * @example\n * // Account Hoisting\n * import { createWalletClient, http } from 'viem'\n * import { privateKeyToAccount } from 'viem/accounts'\n * import { mainnet } from 'viem/chains'\n * import { signTypedData } from 'viem/wallet'\n *\n * const client = createWalletClient({\n *   account: privateKeyToAccount('0x…'),\n *   chain: mainnet,\n *   transport: http(),\n * })\n * const signature = await signTypedData(client, {\n *   domain: {\n *     name: 'Ether Mail',\n *     version: '1',\n *     chainId: 1,\n *     verifyingContract: '0xCcCCccccCCCCcCCCCCCcCcCccCcCCCcCcccccccC',\n *   },\n *   types: {\n *     Person: [\n *       { name: 'name', type: 'string' },\n *       { name: 'wallet', type: 'address' },\n *     ],\n *     Mail: [\n *       { name: 'from', type: 'Person' },\n *       { name: 'to', type: 'Person' },\n *       { name: 'contents', type: 'string' },\n *     ],\n *   },\n *   primaryType: 'Mail',\n *   message: {\n *     from: {\n *       name: 'Cow',\n *       wallet: '0xCD2a3d9F938E13CD947Ec05AbC7FE734Df8DD826',\n *     },\n *     to: {\n *       name: 'Bob',\n *       wallet: '0xbBbBBBBbbBBBbbbBbbBbbbbBBbBbbbbBbBbbBBbB',\n *     },\n *     contents: 'Hello, Bob!',\n *   },\n * })\n */\nexport async function signTypedData<\n    entryPoint extends EntryPoint,\n    const TTypedData extends TypedData | { [key: string]: unknown },\n    TPrimaryType extends string,\n    TChain extends Chain | undefined,\n    TAccount extends SmartAccount<entryPoint> | undefined\n>(\n    client: Client<Transport, TChain, TAccount>,\n    {\n        account: account_ = client.account,\n        domain,\n        message,\n        primaryType,\n        types: types_\n    }: SignTypedDataParameters<TTypedData, TPrimaryType, TAccount>\n): Promise<SignTypedDataReturnType> {\n    if (!account_) {\n        throw new AccountOrClientNotFoundError({\n            docsPath: \"/docs/actions/wallet/signMessage\"\n        })\n    }\n\n    const account = parseAccount(account_)\n\n    const types = {\n        EIP712Domain: getTypesForEIP712Domain({ domain }),\n        ...(types_ as TTypedData)\n    }\n\n    validateTypedData({\n        domain,\n        message,\n        primaryType,\n        types\n    } as TypedDataDefinition)\n\n    if (account.type === \"local\") {\n        return account.signTypedData({\n            domain,\n            primaryType,\n            types,\n            message\n        } as TypedDataDefinition)\n    }\n\n    throw new Error(\"Sign type message is not supported by this account\")\n}\n", "import type {\n    Address,\n    Chain,\n    Client,\n    Hash,\n    Hex,\n    SendTransactionParameters,\n    Transport\n} from \"viem\"\nimport { getAction } from \"viem/utils\"\nimport { type SmartAccount } from \"../../accounts/types\"\nimport type { GetAccountParameter, Prettify } from \"../../types/\"\nimport type { EntryPoint } from \"../../types/entrypoint\"\nimport { AccountOrClientNotFoundError, parseAccount } from \"../../utils/\"\nimport { waitForUserOperationReceipt } from \"../bundler/waitForUserOperationReceipt\"\nimport { type Middleware } from \"./prepareUserOperationRequest\"\nimport { sendUserOperation } from \"./sendUserOperation\"\n\nexport type SendTransactionsWithPaymasterParameters<\n    entryPoint extends EntryPoint,\n    TAccount extends SmartAccount<entryPoint> | undefined =\n        | SmartAccount<entryPoint>\n        | undefined\n> = {\n    transactions: { to: Address; value: bigint; data: Hex }[]\n} & GetAccountParameter<entryPoint, TAccount> &\n    Middleware<entryPoint> & {\n        maxFeePerGas?: bigint\n        maxPriorityFeePerGas?: bigint\n        nonce?: bigint\n    }\n\n/**\n * Creates, signs, and sends a new transactions to the network.\n * This function also allows you to sponsor this transaction if sender is a smartAccount\n *\n * @param client - Client to use\n * @param parameters - {@link SendTransactionParameters}\n * @returns The [Transaction](https://viem.sh/docs/glossary/terms.html#transaction) hash.\n *\n * @example\n * import { createWalletClient, custom } from 'viem'\n * import { mainnet } from 'viem/chains'\n * import { sendTransaction } from 'viem/wallet'\n *\n * const client = createWalletClient({\n *   chain: mainnet,\n *   transport: custom(window.ethereum),\n * })\n * const hash = await sendTransaction(client, [{\n *   account: '0xA0Cf798816D4b9b9866b5330EEa46a18382f251e',\n *   to: '0x70997970c51812dc3a010c7d01b50e0d17dc79c8',\n *   value: 1000000000000000000n,\n * }, {\n *   to: '0x61897970c51812dc3a010c7d01b50e0d17dc1234',\n *   value: 10000000000000000n,\n * }])\n *\n * @example\n * // Account Hoisting\n * import { createWalletClient, http } from 'viem'\n * import { privateKeyToAccount } from 'viem/accounts'\n * import { mainnet } from 'viem/chains'\n * import { sendTransaction } from 'viem/wallet'\n *\n * const client = createWalletClient({\n *   account: privateKeyToAccount('0x…'),\n *   chain: mainnet,\n *   transport: http(),\n * })\n * const hash = await sendTransactions(client, [{\n *   to: '0x70997970c51812dc3a010c7d01b50e0d17dc79c8',\n *   value: 1000000000000000000n,\n * }, {\n *   to: '0x61897970c51812dc3a010c7d01b50e0d17dc1234',\n *   value: 10000000000000000n,\n * }])\n */\nexport async function sendTransactions<\n    TChain extends Chain | undefined,\n    TAccount extends SmartAccount<entryPoint> | undefined,\n    entryPoint extends EntryPoint\n>(\n    client: Client<Transport, TChain, TAccount>,\n    args: Prettify<\n        SendTransactionsWithPaymasterParameters<entryPoint, TAccount>\n    >\n): Promise<Hash> {\n    const {\n        account: account_ = client.account,\n        transactions,\n        middleware,\n        maxFeePerGas,\n        maxPriorityFeePerGas,\n        nonce\n    } = args\n\n    if (!account_) {\n        throw new AccountOrClientNotFoundError({\n            docsPath: \"/docs/actions/wallet/sendTransaction\"\n        })\n    }\n\n    const account = parseAccount(account_) as SmartAccount<entryPoint>\n\n    if (account.type !== \"local\") {\n        throw new Error(\"RPC account type not supported\")\n    }\n\n    const callData = await account.encodeCallData(\n        transactions.map(({ to, value, data }) => {\n            if (!to) throw new Error(\"Missing to address\")\n            return {\n                to,\n                value: value || BigInt(0),\n                data: data || \"0x\"\n            }\n        })\n    )\n\n    const userOpHash = await getAction(\n        client,\n        sendUserOperation<entryPoint>,\n        \"sendUserOperation\"\n    )({\n        userOperation: {\n            sender: account.address,\n            maxFeePerGas: maxFeePerGas || BigInt(0),\n            maxPriorityFeePerGas: maxPriorityFeePerGas || BigInt(0),\n            callData: callData,\n            nonce: nonce\n        },\n        account: account,\n        middleware\n    })\n\n    const userOperationReceipt = await getAction(\n        client,\n        waitForUserOperationReceipt,\n        \"waitForUserOperationReceipt\"\n    )({\n        hash: userOpHash\n    })\n\n    return userOperationReceipt?.receipt.transactionHash\n}\n", "import {\n    type Abi,\n    type Chain,\n    type Client,\n    type ContractFunctionArgs,\n    type ContractFunctionName,\n    type EncodeFunctionDataParameters,\n    type Hash,\n    type Transport,\n    type WriteContractParameters,\n    encodeFunctionData\n} from \"viem\"\nimport { getAction } from \"viem/utils\"\nimport { type SmartAccount } from \"../../accounts/types\"\nimport type { EntryPoint } from \"../../types/entrypoint\"\nimport { type Middleware } from \"./prepareUserOperationRequest\"\nimport {\n    type SendTransactionWithPaymasterParameters,\n    sendTransaction\n} from \"./sendTransaction\"\n\n/**\n * Executes a write function on a contract.\n * This function also allows you to sponsor this transaction if sender is a smartAccount\n *\n * - Docs: https://viem.sh/docs/contract/writeContract.html\n * - Examples: https://stackblitz.com/github/wagmi-dev/viem/tree/main/examples/contracts/writing-to-contracts\n *\n * A \"write\" function on a Solidity contract modifies the state of the blockchain. These types of functions require gas to be executed, and hence a [Transaction](https://viem.sh/docs/glossary/terms.html) is needed to be broadcast in order to change the state.\n *\n * Internally, uses a [Wallet Client](https://viem.sh/docs/clients/wallet.html) to call the [`sendTransaction` action](https://viem.sh/docs/actions/wallet/sendTransaction.html) with [ABI-encoded `data`](https://viem.sh/docs/contract/encodeFunctionData.html).\n *\n * __Warning: The `write` internally sends a transaction – it does not validate if the contract write will succeed (the contract may throw an error). It is highly recommended to [simulate the contract write with `contract.simulate`](https://viem.sh/docs/contract/writeContract.html#usage) before you execute it.__\n *\n * @param client - Client to use\n * @param parameters - {@link WriteContractParameters}\n * @returns A [Transaction Hash](https://viem.sh/docs/glossary/terms.html#hash).\n *\n * @example\n * import { createWalletClient, custom, parseAbi } from 'viem'\n * import { mainnet } from 'viem/chains'\n * import { writeContract } from 'viem/contract'\n *\n * const client = createWalletClient({\n *   chain: mainnet,\n *   transport: custom(window.ethereum),\n * })\n * const hash = await writeContract(client, {\n *   address: '0xFBA3912Ca04dd458c843e2EE08967fC04f3579c2',\n *   abi: parseAbi(['function mint(uint32 tokenId) nonpayable']),\n *   functionName: 'mint',\n *   args: [69420],\n * })\n *\n * @example\n * // With Validation\n * import { createWalletClient, http, parseAbi } from 'viem'\n * import { mainnet } from 'viem/chains'\n * import { simulateContract, writeContract } from 'viem/contract'\n *\n * const client = createWalletClient({\n *   chain: mainnet,\n *   transport: http(),\n * })\n * const { request } = await simulateContract(client, {\n *   address: '0xFBA3912Ca04dd458c843e2EE08967fC04f3579c2',\n *   abi: parseAbi(['function mint(uint32 tokenId) nonpayable']),\n *   functionName: 'mint',\n *   args: [69420],\n * }\n * const hash = await writeContract(client, request)\n */\nexport type WriteContractWithPaymasterParameters<\n    entryPoint extends EntryPoint,\n    TChain extends Chain | undefined = Chain | undefined,\n    TAccount extends SmartAccount<entryPoint> | undefined =\n        | SmartAccount<entryPoint>\n        | undefined,\n    TAbi extends Abi | readonly unknown[] = Abi | readonly unknown[],\n    TFunctionName extends ContractFunctionName<\n        TAbi,\n        \"nonpayable\" | \"payable\"\n    > = ContractFunctionName<TAbi, \"nonpayable\" | \"payable\">,\n    TArgs extends ContractFunctionArgs<\n        TAbi,\n        \"nonpayable\" | \"payable\",\n        TFunctionName\n    > = ContractFunctionArgs<TAbi, \"nonpayable\" | \"payable\", TFunctionName>,\n    TChainOverride extends Chain | undefined = undefined\n> = WriteContractParameters<\n    TAbi,\n    TFunctionName,\n    TArgs,\n    TChain,\n    TAccount,\n    TChainOverride\n> &\n    Middleware<entryPoint>\n\nexport async function writeContract<\n    entryPoint extends EntryPoint,\n    TChain extends Chain | undefined,\n    TAccount extends SmartAccount<entryPoint> | undefined,\n    const TAbi extends Abi | readonly unknown[],\n    TFunctionName extends ContractFunctionName<\n        TAbi,\n        \"nonpayable\" | \"payable\"\n    > = ContractFunctionName<TAbi, \"nonpayable\" | \"payable\">,\n    TArgs extends ContractFunctionArgs<\n        TAbi,\n        \"nonpayable\" | \"payable\",\n        TFunctionName\n    > = ContractFunctionArgs<TAbi, \"nonpayable\" | \"payable\", TFunctionName>,\n    TChainOverride extends Chain | undefined = undefined\n>(\n    client: Client<Transport, TChain, TAccount>,\n    {\n        abi,\n        address,\n        args,\n        dataSuffix,\n        functionName,\n        ...request\n    }: WriteContractWithPaymasterParameters<\n        entryPoint,\n        TChain,\n        TAccount,\n        TAbi,\n        TFunctionName,\n        TArgs,\n        TChainOverride\n    >\n): Promise<Hash> {\n    const data = encodeFunctionData<TAbi, TFunctionName>({\n        abi,\n        args,\n        functionName\n    } as EncodeFunctionDataParameters<TAbi, TFunctionName>)\n    const hash = await getAction(\n        client,\n        sendTransaction<TChain, TAccount, entryPoint, TChainOverride>,\n        \"sendTransaction\"\n    )({\n        data: `${data}${dataSuffix ? dataSuffix.replace(\"0x\", \"\") : \"\"}`,\n        to: address,\n        ...request\n    } as unknown as SendTransactionWithPaymasterParameters<\n        entryPoint,\n        TChain,\n        TAccount,\n        TChainOverride\n    >)\n    return hash\n}\n", "import type {\n    Abi,\n    Chain,\n    Client,\n    ContractFunctionArgs,\n    ContractFunctionName,\n    DeployContractParameters,\n    Hash,\n    SendTransactionParameters,\n    Transport,\n    TypedData,\n    WriteContractParameters\n} from \"viem\"\nimport type { SmartAccount } from \"../../accounts/types\"\nimport {\n    type SendTransactionsWithPaymasterParameters,\n    sendTransactions\n} from \"../../actions/smartAccount\"\nimport {\n    type DeployContractParametersWithPaymaster,\n    deployContract\n} from \"../../actions/smartAccount/deployContract\"\nimport {\n    type Middleware,\n    type PrepareUserOperationRequestReturnType,\n    prepareUserOperationRequest\n} from \"../../actions/smartAccount/prepareUserOperationRequest\"\nimport {\n    type SendTransactionWithPaymasterParameters,\n    sendTransaction\n} from \"../../actions/smartAccount/sendTransaction\"\nimport {\n    type SendUserOperationParameters,\n    sendUserOperation\n} from \"../../actions/smartAccount/sendUserOperation\"\nimport { signMessage } from \"../../actions/smartAccount/signMessage\"\nimport { signTypedData } from \"../../actions/smartAccount/signTypedData\"\nimport {\n    type WriteContractWithPaymasterParameters,\n    writeContract\n} from \"../../actions/smartAccount/writeContract\"\nimport type { Prettify } from \"../../types/\"\nimport type { StateOverrides } from \"../../types/bundler\"\nimport type { EntryPoint } from \"../../types/entrypoint\"\n\nexport type SmartAccountActions<\n    entryPoint extends EntryPoint,\n    TChain extends Chain | undefined = Chain | undefined,\n    TSmartAccount extends SmartAccount<entryPoint> | undefined =\n        | SmartAccount<entryPoint>\n        | undefined\n> = {\n    /**\n     * Creates, signs, and sends a new transaction to the network.\n     * This function also allows you to sponsor this transaction if sender is a smartAccount\n     *\n     * - Docs: https://viem.sh/docs/actions/wallet/sendTransaction.html\n     * - Examples: https://stackblitz.com/github/wagmi-dev/viem/tree/main/examples/transactions/sending-transactions\n     * - JSON-RPC Methods:\n     *   - JSON-RPC Accounts: [`eth_sendTransaction`](https://ethereum.org/en/developers/docs/apis/json-rpc/#eth_sendtransaction)\n     *   - Local Accounts: [`eth_sendRawTransaction`](https://ethereum.org/en/developers/docs/apis/json-rpc/#eth_sendrawtransaction)\n     *\n     * @param args - {@link SendTransactionParameters}\n     * @returns The [Transaction](https://viem.sh/docs/glossary/terms.html#transaction) hash. {@link SendTransactionReturnType}\n     *\n     * @example\n     * import { createWalletClient, custom } from 'viem'\n     * import { mainnet } from 'viem/chains'\n     *\n     * const client = createWalletClient({\n     *   chain: mainnet,\n     *   transport: custom(window.ethereum),\n     * })\n     * const hash = await client.sendTransaction({\n     *   account: '0xA0Cf798816D4b9b9866b5330EEa46a18382f251e',\n     *   to: '0x70997970c51812dc3a010c7d01b50e0d17dc79c8',\n     *   value: 1000000000000000000n,\n     * })\n     *\n     * @example\n     * // Account Hoisting\n     * import { createWalletClient, http } from 'viem'\n     * import { privateKeyToAccount } from 'viem/accounts'\n     * import { mainnet } from 'viem/chains'\n     *\n     * const client = createWalletClient({\n     *   account: privateKeyToAccount('0x…'),\n     *   chain: mainnet,\n     *   transport: http(),\n     * })\n     * const hash = await client.sendTransaction({\n     *   to: '0x70997970c51812dc3a010c7d01b50e0d17dc79c8',\n     *   value: 1000000000000000000n,\n     * })\n     */\n    sendTransaction: <TChainOverride extends Chain | undefined>(\n        args: SendTransactionParameters<TChain, TSmartAccount, TChainOverride>\n    ) => Promise<Hash>\n    /**\n     * Calculates an Ethereum-specific signature in [EIP-191 format](https://eips.ethereum.org/EIPS/eip-191): `keccak256(\"\\x19Ethereum Signed Message:\\n\" + len(message) + message))`.\n     *\n     * - Docs: https://viem.sh/docs/actions/wallet/signMessage.html\n     * - JSON-RPC Methods:\n     *   - JSON-RPC Accounts: [`personal_sign`](https://docs.metamask.io/guide/signing-data.html#personal-sign)\n     *   - Local Accounts: Signs locally. No JSON-RPC request.\n     *\n     * With the calculated signature, you can:\n     * - use [`verifyMessage`](https://viem.sh/docs/utilities/verifyMessage.html) to verify the signature,\n     * - use [`recoverMessageAddress`](https://viem.sh/docs/utilities/recoverMessageAddress.html) to recover the signing address from a signature.\n     *\n     * @param args - {@link SignMessageParameters}\n     * @returns The signed message. {@link SignMessageReturnType}\n     *\n     * @example\n     * import { createWalletClient, custom } from 'viem'\n     * import { mainnet } from 'viem/chains'\n     *\n     * const client = createWalletClient({\n     *   chain: mainnet,\n     *   transport: custom(window.ethereum),\n     * })\n     * const signature = await client.signMessage({\n     *   account: '0xA0Cf798816D4b9b9866b5330EEa46a18382f251e',\n     *   message: 'hello world',\n     * })\n     *\n     * @example\n     * // Account Hoisting\n     * import { createWalletClient, http } from 'viem'\n     * import { privateKeyToAccount } from 'viem/accounts'\n     * import { mainnet } from 'viem/chains'\n     *\n     * const client = createWalletClient({\n     *   account: privateKeyToAccount('0x…'),\n     *   chain: mainnet,\n     *   transport: http(),\n     * })\n     * const signature = await client.signMessage({\n     *   message: 'hello world',\n     * })\n     */\n    signMessage: (\n        args: Parameters<\n            typeof signMessage<entryPoint, TChain, TSmartAccount>\n        >[1]\n    ) => ReturnType<typeof signMessage<entryPoint, TChain, TSmartAccount>>\n    /**\n     * Signs typed data and calculates an Ethereum-specific signature in [EIP-191 format](https://eips.ethereum.org/EIPS/eip-191): `keccak256(\"\\x19Ethereum Signed Message:\\n\" + len(message) + message))`.\n     *\n     * - Docs: https://viem.sh/docs/actions/wallet/signTypedData.html\n     * - JSON-RPC Methods:\n     *   - JSON-RPC Accounts: [`eth_signTypedData_v4`](https://docs.metamask.io/guide/signing-data.html#signtypeddata-v4)\n     *   - Local Accounts: Signs locally. No JSON-RPC request.\n     *\n     * @param client - Client to use\n     * @param args - {@link SignTypedDataParameters}\n     * @returns The signed data. {@link SignTypedDataReturnType}\n     *\n     * @example\n     * import { createWalletClient, custom } from 'viem'\n     * import { mainnet } from 'viem/chains'\n     *\n     * const client = createWalletClient({\n     *   chain: mainnet,\n     *   transport: custom(window.ethereum),\n     * })\n     * const signature = await client.signTypedData({\n     *   account: '0xA0Cf798816D4b9b9866b5330EEa46a18382f251e',\n     *   domain: {\n     *     name: 'Ether Mail',\n     *     version: '1',\n     *     chainId: 1,\n     *     verifyingContract: '0xCcCCccccCCCCcCCCCCCcCcCccCcCCCcCcccccccC',\n     *   },\n     *   types: {\n     *     Person: [\n     *       { name: 'name', type: 'string' },\n     *       { name: 'wallet', type: 'address' },\n     *     ],\n     *     Mail: [\n     *       { name: 'from', type: 'Person' },\n     *       { name: 'to', type: 'Person' },\n     *       { name: 'contents', type: 'string' },\n     *     ],\n     *   },\n     *   primaryType: 'Mail',\n     *   message: {\n     *     from: {\n     *       name: 'Cow',\n     *       wallet: '0xCD2a3d9F938E13CD947Ec05AbC7FE734Df8DD826',\n     *     },\n     *     to: {\n     *       name: 'Bob',\n     *       wallet: '0xbBbBBBBbbBBBbbbBbbBbbbbBBbBbbbbBbBbbBBbB',\n     *     },\n     *     contents: 'Hello, Bob!',\n     *   },\n     * })\n     *\n     * @example\n     * // Account Hoisting\n     * import { createWalletClient, http } from 'viem'\n     * import { privateKeyToAccount } from 'viem/accounts'\n     * import { mainnet } from 'viem/chains'\n     *\n     * const client = createWalletClient({\n     *   account: privateKeyToAccount('0x…'),\n     *   chain: mainnet,\n     *   transport: http(),\n     * })\n     * const signature = await client.signTypedData({\n     *   domain: {\n     *     name: 'Ether Mail',\n     *     version: '1',\n     *     chainId: 1,\n     *     verifyingContract: '0xCcCCccccCCCCcCCCCCCcCcCccCcCCCcCcccccccC',\n     *   },\n     *   types: {\n     *     Person: [\n     *       { name: 'name', type: 'string' },\n     *       { name: 'wallet', type: 'address' },\n     *     ],\n     *     Mail: [\n     *       { name: 'from', type: 'Person' },\n     *       { name: 'to', type: 'Person' },\n     *       { name: 'contents', type: 'string' },\n     *     ],\n     *   },\n     *   primaryType: 'Mail',\n     *   message: {\n     *     from: {\n     *       name: 'Cow',\n     *       wallet: '0xCD2a3d9F938E13CD947Ec05AbC7FE734Df8DD826',\n     *     },\n     *     to: {\n     *       name: 'Bob',\n     *       wallet: '0xbBbBBBBbbBBBbbbBbbBbbbbBBbBbbbbBbBbbBBbB',\n     *     },\n     *     contents: 'Hello, Bob!',\n     *   },\n     * })\n     */\n    signTypedData: <\n        const TTypedData extends TypedData | { [key: string]: unknown },\n        TPrimaryType extends string\n    >(\n        args: Parameters<\n            typeof signTypedData<\n                entryPoint,\n                TTypedData,\n                TPrimaryType,\n                TChain,\n                TSmartAccount\n            >\n        >[1]\n    ) => ReturnType<\n        typeof signTypedData<\n            entryPoint,\n            TTypedData,\n            TPrimaryType,\n            TChain,\n            TSmartAccount\n        >\n    >\n    /**\n     * Deploys a contract to the network, given bytecode and constructor arguments.\n     * This function also allows you to sponsor this transaction if sender is a smartAccount\n     *\n     * - Docs: https://viem.sh/docs/contract/deployContract.html\n     * - Examples: https://stackblitz.com/github/wagmi-dev/viem/tree/main/examples/contracts/deploying-contracts\n     *\n     * @param args - {@link DeployContractParameters}\n     * @returns The [Transaction](https://viem.sh/docs/glossary/terms.html#transaction) hash. {@link DeployContractReturnType}\n     *\n     * @example\n     * import { createWalletClient, http } from 'viem'\n     * import { privateKeyToAccount } from 'viem/accounts'\n     * import { mainnet } from 'viem/chains'\n     *\n     * const client = createWalletClient({\n     *   account: privateKeyToAccount('0x…'),\n     *   chain: mainnet,\n     *   transport: http(),\n     * })\n     * const hash = await client.deployContract({\n     *   abi: [],\n     *   account: '0x…,\n     *   bytecode: '0x608060405260405161083e38038061083e833981016040819052610...',\n     * })\n     */\n    deployContract: <\n        const TAbi extends Abi | readonly unknown[],\n        TChainOverride extends Chain | undefined = undefined\n    >(\n        args: Prettify<\n            DeployContractParameters<\n                TAbi,\n                TChain,\n                TSmartAccount,\n                TChainOverride\n            >\n        >\n    ) => ReturnType<typeof deployContract<entryPoint, TChain, TSmartAccount>>\n    /**\n     * Executes a write function on a contract.\n     * This function also allows you to sponsor this transaction if sender is a smartAccount\n     *\n     * - Docs: https://viem.sh/docs/contract/writeContract.html\n     * - Examples: https://stackblitz.com/github/wagmi-dev/viem/tree/main/examples/contracts/writing-to-contracts\n     *\n     * A \"write\" function on a Solidity contract modifies the state of the blockchain. These types of functions require gas to be executed, and hence a [Transaction](https://viem.sh/docs/glossary/terms.html) is needed to be broadcast in order to change the state.\n     *\n     * Internally, uses a [Wallet Client](https://viem.sh/docs/clients/wallet.html) to call the [`sendTransaction` action](https://viem.sh/docs/actions/wallet/sendTransaction.html) with [ABI-encoded `data`](https://viem.sh/docs/contract/encodeFunctionData.html).\n     *\n     * __Warning: The `write` internally sends a transaction – it does not validate if the contract write will succeed (the contract may throw an error). It is highly recommended to [simulate the contract write with `contract.simulate`](https://viem.sh/docs/contract/writeContract.html#usage) before you execute it.__\n     *\n     * @param args - {@link WriteContractParameters}\n     * @returns A [Transaction Hash](https://viem.sh/docs/glossary/terms.html#hash). {@link WriteContractReturnType}\n     *\n     * @example\n     * import { createWalletClient, custom, parseAbi } from 'viem'\n     * import { mainnet } from 'viem/chains'\n     *\n     * const client = createWalletClient({\n     *   chain: mainnet,\n     *   transport: custom(window.ethereum),\n     * })\n     * const hash = await client.writeContract({\n     *   address: '0xFBA3912Ca04dd458c843e2EE08967fC04f3579c2',\n     *   abi: parseAbi(['function mint(uint32 tokenId) nonpayable']),\n     *   functionName: 'mint',\n     *   args: [69420],\n     * })\n     *\n     * @example\n     * // With Validation\n     * import { createWalletClient, custom, parseAbi } from 'viem'\n     * import { mainnet } from 'viem/chains'\n     *\n     * const client = createWalletClient({\n     *   chain: mainnet,\n     *   transport: custom(window.ethereum),\n     * })\n     * const { request } = await client.simulateContract({\n     *   address: '0xFBA3912Ca04dd458c843e2EE08967fC04f3579c2',\n     *   abi: parseAbi(['function mint(uint32 tokenId) nonpayable']),\n     *   functionName: 'mint',\n     *   args: [69420],\n     * }\n     * const hash = await client.writeContract(request)\n     */\n    writeContract: <\n        const TAbi extends Abi | readonly unknown[],\n        TFunctionName extends ContractFunctionName<\n            TAbi,\n            \"nonpayable\" | \"payable\"\n        > = ContractFunctionName<TAbi, \"nonpayable\" | \"payable\">,\n        TArgs extends ContractFunctionArgs<\n            TAbi,\n            \"nonpayable\" | \"payable\",\n            TFunctionName\n        > = ContractFunctionArgs<TAbi, \"nonpayable\" | \"payable\", TFunctionName>,\n        TChainOverride extends Chain | undefined = undefined\n    >(\n        args: WriteContractParameters<\n            TAbi,\n            TFunctionName,\n            TArgs,\n            TChain,\n            TSmartAccount,\n            TChainOverride\n        >\n    ) => ReturnType<\n        typeof writeContract<\n            entryPoint,\n            TChain,\n            TSmartAccount,\n            TAbi,\n            TFunctionName,\n            TArgs,\n            TChainOverride\n        >\n    >\n    prepareUserOperationRequest: <TTransport extends Transport>(\n        args: Prettify<\n            Parameters<\n                typeof prepareUserOperationRequest<\n                    entryPoint,\n                    TTransport,\n                    TChain,\n                    TSmartAccount\n                >\n            >[1]\n        >,\n        stateOverrides?: StateOverrides\n    ) => Promise<Prettify<PrepareUserOperationRequestReturnType<entryPoint>>>\n    sendUserOperation: <TTransport extends Transport>(\n        args: Prettify<\n            Parameters<\n                typeof sendUserOperation<\n                    entryPoint,\n                    TTransport,\n                    TChain,\n                    TSmartAccount\n                >\n            >[1]\n        >\n    ) => Promise<Hash>\n    /**\n     * Creates, signs, and sends a new transaction to the network.\n     * This function also allows you to sponsor this transaction if sender is a smartAccount\n     *\n     * - Docs: https://viem.sh/docs/actions/wallet/sendTransaction.html\n     * - Examples: https://stackblitz.com/github/wagmi-dev/viem/tree/main/examples/transactions/sending-transactions\n     * - JSON-RPC Methods:\n     *   - JSON-RPC Accounts: [`eth_sendTransaction`](https://ethereum.org/en/developers/docs/apis/json-rpc/#eth_sendtransaction)\n     *   - Local Accounts: [`eth_sendRawTransaction`](https://ethereum.org/en/developers/docs/apis/json-rpc/#eth_sendrawtransaction)\n     *\n     * @param args - {@link SendTransactionParameters}\n     * @returns The [Transaction](https://viem.sh/docs/glossary/terms.html#transaction) hash. {@link SendTransactionReturnType}\n     *\n     * @example\n     * import { createWalletClient, custom } from 'viem'\n     * import { mainnet } from 'viem/chains'\n     *\n     * const client = createWalletClient({\n     *   chain: mainnet,\n     *   transport: custom(window.ethereum),\n     * })\n     * const hash = await client.sendTransaction([{\n     *   account: '0xA0Cf798816D4b9b9866b5330EEa46a18382f251e',\n     *   to: '0x70997970c51812dc3a010c7d01b50e0d17dc79c8',\n     *   value: 1000000000000000000n\n     * }, {\n     *   to: '0x61897970c51812dc3a010c7d01b50e0d17dc1234',\n     *   value: 10000000000000000n\n     * })\n     *\n     * @example\n     * // Account Hoisting\n     * import { createWalletClient, http } from 'viem'\n     * import { privateKeyToAccount } from 'viem/accounts'\n     * import { mainnet } from 'viem/chains'\n     *\n     * const client = createWalletClient({\n     *   account: privateKeyToAccount('0x…'),\n     *   chain: mainnet,\n     *   transport: http(),\n     * })\n     * const hash = await client.sendTransaction([{\n     *   to: '0x70997970c51812dc3a010c7d01b50e0d17dc79c8',\n     *   value: 1000000000000000000n\n     * }, {\n     *   to: '0x61897970c51812dc3a010c7d01b50e0d17dc1234',\n     *   value: 10000000000000000n\n     * }])\n     */\n    sendTransactions: (\n        args: Prettify<\n            SendTransactionsWithPaymasterParameters<entryPoint, TSmartAccount>\n        >\n    ) => ReturnType<typeof sendTransactions<TChain, TSmartAccount, entryPoint>>\n}\n\nexport function smartAccountActions<entryPoint extends EntryPoint>({\n    middleware\n}: Middleware<entryPoint>) {\n    return <\n        TTransport extends Transport,\n        TChain extends Chain | undefined = Chain | undefined,\n        TSmartAccount extends SmartAccount<entryPoint> | undefined =\n            | SmartAccount<entryPoint>\n            | undefined\n    >(\n        client: Client<TTransport, TChain, TSmartAccount>\n    ): SmartAccountActions<entryPoint, TChain, TSmartAccount> => ({\n        prepareUserOperationRequest: (args, stateOverrides) =>\n            prepareUserOperationRequest(\n                client,\n                {\n                    ...args,\n                    middleware\n                },\n                stateOverrides\n            ),\n        deployContract: (args) =>\n            deployContract(client, {\n                ...args,\n                middleware\n            } as DeployContractParametersWithPaymaster<entryPoint>),\n        sendTransaction: (args) =>\n            sendTransaction<TChain, TSmartAccount, entryPoint>(client, {\n                ...args,\n                middleware\n            } as SendTransactionWithPaymasterParameters<\n                entryPoint,\n                TChain,\n                TSmartAccount\n            >),\n        sendTransactions: (args) =>\n            sendTransactions<TChain, TSmartAccount, entryPoint>(client, {\n                ...args,\n                middleware\n            }),\n        sendUserOperation: (args) =>\n            sendUserOperation<entryPoint, TTransport, TChain, TSmartAccount>(\n                client,\n                {\n                    ...args,\n                    middleware\n                } as SendUserOperationParameters<entryPoint, TSmartAccount>\n            ),\n        signMessage: (args) =>\n            signMessage<entryPoint, TChain, TSmartAccount>(client, args),\n        signTypedData: <\n            const TTypedData extends TypedData | { [key: string]: unknown },\n            TPrimaryType extends string\n        >(\n            args: Parameters<\n                typeof signTypedData<\n                    entryPoint,\n                    TTypedData,\n                    TPrimaryType,\n                    TChain,\n                    TSmartAccount\n                >\n            >[1]\n        ) =>\n            signTypedData<\n                entryPoint,\n                TTypedData,\n                TPrimaryType,\n                TChain,\n                TSmartAccount\n            >(client, args),\n        writeContract: <\n            const TAbi extends Abi | readonly unknown[],\n            TFunctionName extends ContractFunctionName<\n                TAbi,\n                \"nonpayable\" | \"payable\"\n            > = ContractFunctionName<TAbi, \"nonpayable\" | \"payable\">,\n            TArgs extends ContractFunctionArgs<\n                TAbi,\n                \"nonpayable\" | \"payable\",\n                TFunctionName\n            > = ContractFunctionArgs<\n                TAbi,\n                \"nonpayable\" | \"payable\",\n                TFunctionName\n            >,\n            TChainOverride extends Chain | undefined = undefined\n        >(\n            args: WriteContractParameters<\n                TAbi,\n                TFunctionName,\n                TArgs,\n                TChain,\n                TSmartAccount,\n                TChainOverride\n            >\n        ) =>\n            writeContract(client, {\n                ...args,\n                middleware\n            } as WriteContractWithPaymasterParameters<\n                entryPoint,\n                TChain,\n                TSmartAccount,\n                TAbi\n            >)\n    })\n}\n", "import type {\n    Chain,\n    Client,\n    ClientConfig,\n    Transport,\n    WalletClientConfig\n} from \"viem\"\nimport { createClient } from \"viem\"\nimport { type SmartAccount } from \"../accounts/types\"\nimport { type Middleware } from \"../actions/smartAccount/prepareUserOperationRequest\"\nimport type { Prettify } from \"../types/\"\nimport { type BundlerRpcSchema } from \"../types/bundler\"\nimport type { EntryPoint } from \"../types/entrypoint\"\nimport {\n    type SmartAccountActions,\n    smartAccountActions\n} from \"./decorators/smartAccount\"\n\n/**\n * TODO:\n *  - Add docs\n *  - Fix typing, 'accounts' is required to signMessage, signTypedData, signTransaction, but not needed here, since account is embedded in the client\n */\nexport type SmartAccountClient<\n    entryPoint extends EntryPoint,\n    transport extends Transport = Transport,\n    chain extends Chain | undefined = Chain | undefined,\n    account extends SmartAccount<entryPoint> | undefined =\n        | SmartAccount<entryPoint>\n        | undefined\n> = Prettify<\n    Client<\n        transport,\n        chain,\n        account,\n        BundlerRpcSchema<entryPoint>,\n        SmartAccountActions<entryPoint, chain, account>\n    >\n>\n\nexport type SmartAccountClientConfig<\n    entryPoint extends EntryPoint,\n    transport extends Transport = Transport,\n    chain extends Chain | undefined = Chain | undefined,\n    account extends SmartAccount<entryPoint> | undefined =\n        | SmartAccount<entryPoint>\n        | undefined\n> = Prettify<\n    Pick<\n        ClientConfig<transport, chain, account>,\n        \"cacheTime\" | \"chain\" | \"key\" | \"name\" | \"pollingInterval\"\n    > &\n        Middleware<entryPoint> & {\n            account: account\n            bundlerTransport: Transport\n        } & {\n            entryPoint?: entryPoint\n        }\n>\n\n/**\n * Creates a EIP-4337 compliant Bundler Client with a given [Transport](https://viem.sh/docs/clients/intro.html) configured for a [Chain](https://viem.sh/docs/clients/chains.html).\n *\n * - Docs: https://docs.pimlico.io/permissionless/reference/clients/smartAccountClient\n *\n * A Bundler Client is an interface to \"erc 4337\" [JSON-RPC API](https://eips.ethereum.org/EIPS/eip-4337#rpc-methods-eth-namespace) methods such as sending user operation, estimating gas for a user operation, get user operation receipt, etc through Bundler Actions.\n *\n * @param parameters - {@link WalletClientConfig}\n * @returns A Bundler Client. {@link SmartAccountClient}\n *\n * @example\n * import { createPublicClient, http } from 'viem'\n * import { mainnet } from 'viem/chains'\n *\n * const smartAccountClient = createSmartAccountClient({\n *   chain: mainnet,\n *   transport: http(BUNDLER_URL),\n * })\n */\n\nexport function createSmartAccountClient<\n    TSmartAccount extends SmartAccount<TEntryPoint> | undefined,\n    TTransport extends Transport = Transport,\n    TChain extends Chain | undefined = undefined,\n    TEntryPoint extends EntryPoint = TSmartAccount extends SmartAccount<infer U>\n        ? U\n        : never\n>(\n    parameters: SmartAccountClientConfig<\n        TEntryPoint,\n        TTransport,\n        TChain,\n        TSmartAccount\n    >\n): SmartAccountClient<TEntryPoint, TTransport, TChain, TSmartAccount> {\n    const {\n        key = \"Account\",\n        name = \"Smart Account Client\",\n        bundlerTransport\n    } = parameters\n    const client = createClient({\n        ...parameters,\n        key,\n        name,\n        transport: bundlerTransport,\n        type: \"smartAccountClient\"\n    })\n\n    return client.extend(\n        smartAccountActions({\n            middleware: parameters.middleware\n        })\n    ) as SmartAccountClient<TEntryPoint, TTransport, TChain, TSmartAccount>\n}\n"],
  "mappings": "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",
  "names": ["sendUserOperation", "sendUserOperation", "sendUserOperation", "sendUserOperation", "sendUserOperation"]
}
